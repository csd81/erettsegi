# V. PROCEDURES AND FUNCTIONS
## 117


---

### V. PROCEDURES AND FUNCTIONS

Procedures and functions are subprograms (also called subroutines). With their help, we can divide our programs into smaller parts, making them modular. We write the subprogram and then refer to it by name. In the main program, we only call the subprogram by its name.

One of the main advantages of using procedures and functions is the avoidance of code repetition. The program becomes shorter, more transparent, and it is enough to change the subprogram if there is a code error or if we want it to work differently in the future. Another advantage is that a larger program, broken into smaller parts, can be solved by multiple people working as a team.

The use of procedures and functions changes the basic sequence of instruction execution. In subprograms and the main program, the execution order remains sequential. Calling a subprogram, the program execution jumps to the first line of the subprogram. After the subprogram finishes, execution continues in the main program from the line after the call.

Look at the diagram on the right! There is a main program with several tasks. To improve readability, we separate the tasks on the screen with dashed lines (and a blank line). At the end of each task, we place a call to a procedure with a descriptive name. Think about whether placing this procedure will make your code shorter and clearer. If we decide that a procedure would fit well, we can place it at the end of the program. In case of multiple procedures, we can place them one after another. It’s a good practice to have at least three lines of content in each procedure. Additionally, if we want to reuse a task in multiple places, it's worth writing it as a procedure, making the program more concise and easier to maintain.

---


## 118

Here’s the full English translation of the text:

---

### PROCEDURES

A procedure is a subprogram. Its effect is carried out by performing some task. For example, it may display something on the screen or modify data in a file or database.

#### Procedure without parameters

The procedure must be defined before the place where it is called. That is, if we want to use a procedure in the main program (`main`), we need to write the procedure in the preceding lines. If we want to use `subprogram2` in a procedure called `subprogram1`, then `subprogram2` must be created before `subprogram1`. (See the attached diagram!)

To create a procedure, we start with the `void` keyword. In C#, this is preceded by `static` (1). This is followed by the procedure name, then an empty pair of parentheses if there are no parameters being passed. The body of the procedure is given in curly braces `{}` as a block of instructions.

We call the procedure from the main program by its name and an empty pair of parentheses.

---

### C# version

```cs
static void szegely()
{
    int i;
    Console.Write(" ");
    for (i = 1; i <= 3; i++)
        Console.Write(i);
    Console.WriteLine('\n');
    for (i = 1; i <= 3; i++)
        Console.WriteLine(i);
}
static void Main(string[] args)
{
szegely();
}
```

---

### C++ version

```cpp
void szegely() {
    int i;
    cout << " ";
    for (i = 1; i <= 3; i++)
        cout << i;
    cout << endl << endl;
    for (i = 1; i <= 3; i++)
    cout << i << endl;
}
int main() {
    szegely();
}
```



## 119



### Procedure with parameter passing

The variables created within the procedure are valid only within that procedure, while the variables created in the main program are valid in the main program. We can pass the values of certain variables from the main program to the procedure using parameters. The parameters are given between the parentheses after the procedure name.

When creating a procedure, the names and types of the variables used as parameters must be listed between the parentheses. These will (by default) be substituted with the values provided between the parentheses during the call of the procedure in the main program, in the given order. In the illustration, the value 10 is placed into the variable `v`, and the value 5 into `f`.

For example, the `szegely` (border) procedure defines the size of a game field in a tic-tac-toe game, in terms of the number of fields per row and column. The first parameter (v) defines the horizontal size of the field, and the second parameter (f) defines the vertical size.

#### C# version  
```csharp
static void szegely(int v, int f)
{
    int i;
    Console.Write(" ");
    for (i = 1; i <= v; i++)
        Console.Write(i % 10);
    Console.WriteLine("\n");
    for (i = 1; i <= f; i++)
        Console.WriteLine(i % 10);
}
static void Main(string[] args)
{
    szegely(10, 5);
}
```

#### C++ version  
```cpp
void szegely(int v, int f){
    int i;
    cout << " ";
    for (i = 1; i <= v; i++)
        cout << i % 10;
    cout << endl << endl;
    for (i = 1; i <= f; i++)
        cout << i % 10 << endl;
}
int main(){
    szegely(10, 5);
}
```

---

It is also possible to pass arrays as parameters. Passing vectors (arrays) works dynamically, meaning that it is not necessary to specify how many elements the array contains. We can determine the size of the array transferred using a function that retrieves the number of elements within the procedure.

**C#:** To determine the number of elements in a vector, the `Count()` function is used (3).  

**C++:** The `sizeof()` function determines the size in bytes of the variable provided as a parameter. Thus, `sizeof(arrayName)` gives the total size of the array, and `sizeof(arrayName[0])` shows the size of a single element. If we divide the total size of the array by the size of one element, we get the number of elements (3).

In the example applied to the tic-tac-toe game, the notations used can be found in the figure. These parameters are given to the procedure, and then displayed on the screen.

 

# 120



---

### **C# version**
```csharp
static void figlista(char[] atvett) {
    int i, n;
    n = atvett.Count();
    for (i = 0; i <= n - 1; i++)
        Console.Write("({0} ", atvett[i]);
}
static void Main(string[] args) 
{
    char[] fig = new char[3] { '.', 'X', 'O' };
    figlista(fig);
}
```

---

### **C++ version**
```cpp
void figuralista(char atvett[]) {
    int i, n;
    n = sizeof(atvett) / sizeof(atvett[0]);
    for (i = 0; i <= n - 1; i++)
        cout << atvett[i] << ' ';
}
int main() {
    char fig[3] = { '.', 'X', 'O' };
    figuralista(fig);
}
```

---


---

We can also pass matrices as parameters. However, different languages support this in different ways.

**C++:** It is mandatory to specify the number of elements in both directions of the array being passed (1), so a dynamic matrix cannot be passed as a parameter to a subroutine.

**C#:** A subroutine can accept a dynamic matrix. Similar to vectors, it arises here as well: how can we know the size of the array in both directions? The `GetLength` function serves this purpose. Using the parameter `0` refers to the horizontal size, and using parameter `1` refers to the vertical size (lines 3–4).

The two programs are not exactly the same. Their common feature is that they both display the elements of a tic-tac-toe board in matrix form. In the C# version, the main program is not visible. The `tkiir` method prints the received matrix to the screen.

In C++, the procedure prints the elements of a 3x3 matrix, passed as a parameter, one array element at a time.

---



---

### **C# version**
```csharp
static void tkiir(int[,] atvett) {
int i, j, n, m;
n = atvett.GetLength(0);  // Get the number of rows
m = atvett.GetLength(1);  // Get the number of columns
for (i = 0; i <= n - 1; i++) {
for (j = 0; j <= m - 1; j++)
Console.Write(atvett[i, j]);
Console.WriteLine();
}
}
```

---

### **C++ version**
```cpp
void tablakiiir(int atvett[3][3]) {
cout << atvett[2][1];  // Example: print the element at row 2, column 1
}
int main() {
int t[3][3] = { {0, 1, 2},
{1, 2, 1},
{0, 2, 1} };
tablakiiir(t);
}
```

---



# 121

Here is the full translation of the text in the image:

---

## V. PROCEDURES AND FUNCTIONS

### Tasks

1. Create a procedure named *elvalaszto* (separator), which draws a separator line of characters across the entire width of the screen and then leaves a blank line.

2. Modify the previous procedure so that we can specify as a parameter which task number it is, and write it on the screen below the drawn line. The procedure should be suitable for displaying labels such as *3. task*, *b. task*, *3.b. task*.

3. Modify the previous procedure again so that with another parameter we can choose between a full-width and half-width line.

4. For the following tasks, we may use our already existing programs.

5. Create a procedure that displays a 50x50 matrix with row and column numbering. (You may use the code from Task 10 in the *Counter loops* chapter.) The procedure should be named *kep* (image).

Example:
```
00000000001111111111222222222233333333334444444444  
12345678901234567890123456789012345678901234567890  

01  
02  
...  
50
```

6. Modify the previous procedure so that it can display row and column numbering for any square matrix (up to the size that fits on the screen).

7. Modify the previous procedure so that it can display row and column numbering for any size matrix that still fits on the screen.

8. Create a procedure that displays a string of characters in reverse order. The procedure should be called *fordit* (reverse). (It should be called like this: *fordit(szoveg)*.)

9. Create a procedure that displays the letters representing the colors of each pixel in the image, with row and column numbering, from the *kep.txt* file. The procedure should be called *megjelenit* (display), and as parameters, it should receive the three color components of the entire image matrix. (Example: Data storage Task 3, and the call should look like: *megjelenit(r,g,b)*.)

---



# 122
 

---

**FUNCTIONS**  

```
         10       30       20000
          |        |         |
          v        v         v
        length   width      price  
                ↓
         Discounted price  

              16000
```


Functions are procedures that return a single value to the main program. It is often said that the return value of the function is its value. Of course, the function can also perform all the tasks that a procedure would. However, its uniqueness lies in the return value.  

Functions are often illustrated with machines that transform something, similar to how elementary school students imagine machines for certain tasks. The machine’s name, if we’re lucky, refers to the task (e.g., meat grinder), and this can be the function’s name. What we place into the machine is the input parameter (e.g., meat). What comes out of the machine (ground meat) is the result, the return value.  

In textual descriptions, within the function, the return value is marked with the function name (without parameters). The type of the return value is written after the parameter list in textual form, separated by a colon (1).  

In the main program, the return value must be used for something: either printed (8), stored in a variable (6), used with another function call, etc. Using a function as a simple instruction (10) makes no sense and results in an error message, since the return value is created, but nothing is done with it. That would be like placing meat into a meat grinder and then blocking its output.  

The example given introduces functions, as this was part of a final exam task. The task was to determine the amount of discount, where plots 15 meters or narrower or 25 meters or shorter received a 20% discount.  

Writing functions is barely different from writing procedures. At the beginning of the declaration, instead of the keyword `void`, you must specify the return value type (1). The return value itself must be placed after the `return` keyword (3).  

---

 

---

Function `kedv` (h: float, sz: float, a: float) : float  
    If h <= 25 or sz <= 15 then a := 0.8 * a  
    return a  
End of function  

Main program  
    a := kedv(10, 30, 20000)  
    Print: a  
    Print: kedv(20, 30, 30000)  

    // Calling the function directly in print  
    kedv(20, 25, 10000)   // This line is nonsensical, as the function result is not used  

---



# 123



**C# version**  
```csharp
static double kedvez(int h, int sz, double ado) {
    if (sz <= 15 || h <= 25) ado = 0.8 * ado;
    return ado;
}
static void Main(string[] args) {
double a;
    a = kedvez(10, 30, 20000);
    Console.WriteLine(kedvez(20, 30, 30000));
    Console.WriteLine(a);
}
```

**C++ version**  
```cpp
double kedvez(int h, int sz, double ado) {
if (sz <= 15 || h <= 25) ado = 0.8 * ado;
return ado;
}
int main() {
    double a;
    a = kedvez(10, 30, 20000);
cout << kedvez(20, 30, 30000) << endl;
cout << a;
}
```

---

Functions can only return a single value. However, some programming languages allow that this value be a composite type. The original C language does not support this at all. The C++98 version allows returning a record, but not an array. C# can easily return an array as well.

Here's a simple example of this. The `lepes` (step) function takes a 3x3 tic-tac-toe board as a parameter and changes the element in the top-left corner of the array to the value 2 (line 2). Finally, it returns the modified table copy to the main program (line 3), which then modifies the original table.

In terms of coding, the only novelty compared to previous examples is that in the declaration, at the return type, it must be specified that it is a matrix (line 1, after static the int[,]). 

```csharp
static int[,] lepes(int[,] atvett) {
    atvett[0, 0] = 2;
    return atvett;
}
static void Main(string[] args) {
    int[,] t = new int[3,3] { {0, 1, 2},
                              {1, 2, 1},
                              {0, 2, 1} };
    t = lepes(t);
}
```



# 124


---


**Tasks**

1. The factorial of a natural number is the product of the natural numbers from 1 to N. Write a function that receives any natural number as a parameter and returns its factorial.  

2. The first and second elements of the Fibonacci sequence are 1. We always get the next element by adding the previous two elements: 1, 1, 2, 3, 5, 8, 13, ... Create a function that determines the Fibonacci number at the requested position. For example: if we input 7, it returns 13.  

3. For the following tasks, we can use our already existing programs.  

4. A courier receives payment for trips depending on their length, according to the attached table. Write a function that determines the amount of payment based on the given distance!  

| Distance (km) | Payment (Ft) |
|---------------|--------------|
| 1–2           | 500 Ft       |
| 3–5           | 700 Ft       |
| 6–10          | 900 Ft       |
| 11–20         | 1400 Ft      |
| 21–30         | 2000 Ft      |

5. Create a function that, based on the lengths of three line segments, determines whether a triangle can be constructed from those segments. Three line segments can form a triangle only if the sum of the lengths of any two sides is greater than the length of the third side. (Tip: since it’s a decision, what could the return value be?)  

6. Write a function that determines whether any given natural number is prime.  

---



# 125



### SCOPE OF VARIABLES  

Until now, we have created variables in the main program (main) or in functions and procedures. In all cases, they were valid and usable within the program module where they were created. These variables are called **local variables**. These include variables created as parameters of procedures and functions. In the figure, the local variables of the main program are b, f, h, and the local variables of the test1 procedure are a, d, e, f, g.  

If variables are created outside of program modules (main program, functions, procedures), they are accessible from all modules (in the first approximation). These are called **global variables**. In the figure: a, b, c, d. Among these, global variables are truly visible and accessible from every module.  

If a new variable with the same name exists both globally and locally, the local variable will be accessible within that given program module. The local variable will override the global variable. However, this does not mean it overwrites its value. It’s only accessible locally. For example, inside the test1 procedure, the variable a has the value 2, because we are seeing the local variable. Once we exit the procedure, the global variable becomes valid again.  

```c
// Global variables
int a = 1, b = 1, c = 1, d = 1;

void test1(int e, int e2) {
    int a = 2, f = 2, g = 2;
    printf("a: %d, b: %d, c: %d, d: %d, e: %d, f: %d, g: %d\n", a, b, c, d, e, f, g);
    printf("h: %d\n", h); // Will cause an error, h is not declared here
    // end of test1
}

int main() {
    int b = 3, f = 3, h = 3;
    test1(h, f);
    printf("a: %d, b: %d, c: %d, d: %d, f: %d, h: %d\n", a, b, c, d, f, h);
    printf("e: %d, g: %d\n", e, g); // Will cause an error, e and g are not declared here
    return 0;
}
```

Let’s try to follow what the sample program would print out. At first, we get an error message, because in line (5), variable h does not exist, so its value cannot be printed. (Variable h exists only in the main program.) If we comment out line (5), we will still get an error message at line (11), because e and g only exist in the test1 subprogram, and line (11) tries to use them in the main program. If we also comment out line (11), the final output will be:  

```
2, 1, 1, 3, 3, 2  
1, 1, 1, 3, 3  
```

Global variables must be declared before the program modules, mostly in the same way as local variables. In C#, the variable type must also be preceded by the keyword **static**. For example:  
```
static int rszam;
```

# 126



At first glance, global variables are one of the most seductive inventions in the software world. They practically make the use of functions and parameter passing unnecessary, as the data stored in global variables is accessible from both the main and subprograms. In the case of a more complex program, especially if multiple people are writing it, their use requires additional attention and coordination. The clarity of the program code decreases as a result.  

Their use should be reconsidered when dealing with large amounts of data, such as passing large arrays. If local variables are used with value-based parameter passing (see the following chapter), both the original and the copied arrays are created, occupying twice as much space in memory, and exchanging data between variables requires memory operations. It is worth considering how to avoid wasting resources in each case.  

I advise students to use global variables confidently during final exams or competitions. If there is a main data storage array (and there usually is), and its size is large, then a global variable is practical. It is easy to manage, and progress is faster. If every variable had to be local, you would have to remember what value the variable had after the previous use. To transfer values stored in local variables, use parameters and functions.  

---

### Tasks  

1. The following algorithm takes a vector containing whole numbers, rearranges it by placing prime numbers (if any) at the beginning of the vector and composite numbers after the primes. Let’s code this algorithm in the chosen programming language!  

```c
Constant N = 20
Variable A[0..N-1]: array of integers

Procedure Fill
   Loop I from 0 to N-1
      A[I] := RandomInteger(2, 1000)
   End loop
End procedure

Procedure Print
   Loop I from 0 to N-1
      Print A[I]
   End loop
End procedure



Function Prime(A: Integer): Boolean
  I := 2  
  While (I ≤ SquareRoot(A) and (A MOD I ≠ 0))  
    I := I + 1  
  End While  
  Prim := (I > SquareRoot(A))  
End Function  

Procedure PrimePack:
  E := 0  
  V := N - 1  
  S := A[0]  
  While E < V  
    While (E < V and not Prime(A[V]))  
      V := V - 1  
    End While  
    If E < V then  
      A[E] := A[V]  
      E := E + 1  
      While (E < V and Prime(A[E]))  
        E := E + 1  
      End While  
      If E < V then  
        A[V] := A[E]  
      End If  
      V := V - 1  
    End If  
  End While  
  A[E] := S  
End Procedure  

Program PrimePackager:
  Fill  
  Print  
  PrimPack  
  Print  
Program end.  
```

-----
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <cstdlib>
#include <ctime>

const int N = 20;
int A[N];

// Fill procedure: fills the array with random integers between 2 and 1000
void Fill() {
    std::srand(std::time(0));
    for (int i = 0; i < N; ++i) {
        A[i] = rand() % 999 + 2;  // random integer between 2 and 1000
    }
}

// Print procedure: prints the array elements
void Print() {
    for (int i = 0; i < N; ++i) {
        std::cout << A[i] << " ";
    }
    std::cout << std::endl;
}

// Prime function: checks if a number is prime
bool Prime(int a) {
    if (a < 2) return false;
    int limit = static_cast<int>(sqrt(a));
    int i = 2;
    while (i <= limit && (a % i != 0)) {
        i++;
    }
    return (i > limit);
}

// PrimePack procedure: reorders the array so that primes are at the start
void PrimePack() {
    int E = 0;
    int V = N - 1;
    int S = A[0];

    while (E < V) {
        while (E < V && !Prime(A[V])) {
            V--;
        }
        if (E < V) {
            A[E] = A[V];
            E++;
            while (E < V && Prime(A[E])) {
                E++;
            }
            if (E < V) {
                A[V] = A[E];
            }
            V--;
        }
    }
    A[E] = S;
}

// Main program
int main() {
    Fill();
    std::cout << "Original array:\n";
    Print();

    PrimePack();

    std::cout << "Array after PrimePack:\n";
    Print();

    return 0;
}
```


# 127

# 128

# 129

# 130

# 131

# 132

# 133

# 134

# 135

# 136

# 137

# 138

# 139

# 140