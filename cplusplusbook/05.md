# V. PROCEDURES AND FUNCTIONS
## 117


---

### V. PROCEDURES AND FUNCTIONS

Procedures and functions are subprograms (also called subroutines). With their help, we can divide our programs into smaller parts, making them modular. We write the subprogram and then refer to it by name. In the main program, we only call the subprogram by its name.

One of the main advantages of using procedures and functions is the avoidance of code repetition. The program becomes shorter, more transparent, and it is enough to change the subprogram if there is a code error or if we want it to work differently in the future. Another advantage is that a larger program, broken into smaller parts, can be solved by multiple people working as a team.

The use of procedures and functions changes the basic sequence of instruction execution. In subprograms and the main program, the execution order remains sequential. Calling a subprogram, the program execution jumps to the first line of the subprogram. After the subprogram finishes, execution continues in the main program from the line after the call.

Look at the diagram on the right! There is a main program with several tasks. To improve readability, we separate the tasks on the screen with dashed lines (and a blank line). At the end of each task, we place a call to a procedure with a descriptive name. Think about whether placing this procedure will make your code shorter and clearer. If we decide that a procedure would fit well, we can place it at the end of the program. In case of multiple procedures, we can place them one after another. It’s a good practice to have at least three lines of content in each procedure. Additionally, if we want to reuse a task in multiple places, it's worth writing it as a procedure, making the program more concise and easier to maintain.

---


## 118

Here’s the full English translation of the text:

---

### PROCEDURES

A procedure is a subprogram. Its effect is carried out by performing some task. For example, it may display something on the screen or modify data in a file or database.

#### Procedure without parameters

The procedure must be defined before the place where it is called. That is, if we want to use a procedure in the main program (`main`), we need to write the procedure in the preceding lines. If we want to use `subprogram2` in a procedure called `subprogram1`, then `subprogram2` must be created before `subprogram1`. (See the attached diagram!)

To create a procedure, we start with the `void` keyword. In C#, this is preceded by `static` (1). This is followed by the procedure name, then an empty pair of parentheses if there are no parameters being passed. The body of the procedure is given in curly braces `{}` as a block of instructions.

We call the procedure from the main program by its name and an empty pair of parentheses.

---

### C# version

```cs
static void szegely()
{
    int i;
    Console.Write(" ");
    for (i = 1; i <= 3; i++)
        Console.Write(i);
    Console.WriteLine('\n');
    for (i = 1; i <= 3; i++)
        Console.WriteLine(i);
}
static void Main(string[] args)
{
szegely();
}
```

---

### C++ version

```cpp
void szegely() {
    int i;
    cout << " ";
    for (i = 1; i <= 3; i++)
        cout << i;
    cout << endl << endl;
    for (i = 1; i <= 3; i++)
    cout << i << endl;
}
int main() {
    szegely();
}
```



## 119



### Procedure with parameter passing

The variables created within the procedure are valid only within that procedure, while the variables created in the main program are valid in the main program. We can pass the values of certain variables from the main program to the procedure using parameters. The parameters are given between the parentheses after the procedure name.

When creating a procedure, the names and types of the variables used as parameters must be listed between the parentheses. These will (by default) be substituted with the values provided between the parentheses during the call of the procedure in the main program, in the given order. In the illustration, the value 10 is placed into the variable `v`, and the value 5 into `f`.

For example, the `szegely` (border) procedure defines the size of a game field in a tic-tac-toe game, in terms of the number of fields per row and column. The first parameter (v) defines the horizontal size of the field, and the second parameter (f) defines the vertical size.

#### C# version  
```csharp
static void szegely(int v, int f)
{
    int i;
    Console.Write(" ");
    for (i = 1; i <= v; i++)
        Console.Write(i % 10);
    Console.WriteLine("\n");
    for (i = 1; i <= f; i++)
        Console.WriteLine(i % 10);
}
static void Main(string[] args)
{
    szegely(10, 5);
}
```

#### C++ version  
```cpp
void szegely(int v, int f){
    int i;
    cout << " ";
    for (i = 1; i <= v; i++)
        cout << i % 10;
    cout << endl << endl;
    for (i = 1; i <= f; i++)
        cout << i % 10 << endl;
}
int main(){
    szegely(10, 5);
}
```

---

It is also possible to pass arrays as parameters. Passing vectors (arrays) works dynamically, meaning that it is not necessary to specify how many elements the array contains. We can determine the size of the array transferred using a function that retrieves the number of elements within the procedure.

**C#:** To determine the number of elements in a vector, the `Count()` function is used (3).  

**C++:** The `sizeof()` function determines the size in bytes of the variable provided as a parameter. Thus, `sizeof(arrayName)` gives the total size of the array, and `sizeof(arrayName[0])` shows the size of a single element. If we divide the total size of the array by the size of one element, we get the number of elements (3).

In the example applied to the tic-tac-toe game, the notations used can be found in the figure. These parameters are given to the procedure, and then displayed on the screen.

 

# 120



---

### **C# version**
```csharp
static void figlista(char[] atvett) {
    int i, n;
    n = atvett.Count();
    for (i = 0; i <= n - 1; i++)
        Console.Write("({0} ", atvett[i]);
}
static void Main(string[] args) 
{
    char[] fig = new char[3] { '.', 'X', 'O' };
    figlista(fig);
}
```

---

### **C++ version**
```cpp
void figuralista(char atvett[]) {
    int i, n;
    n = sizeof(atvett) / sizeof(atvett[0]);
    for (i = 0; i <= n - 1; i++)
        cout << atvett[i] << ' ';
}
int main() {
    char fig[3] = { '.', 'X', 'O' };
    figuralista(fig);
}
```

---


---

We can also pass matrices as parameters. However, different languages support this in different ways.

**C++:** It is mandatory to specify the number of elements in both directions of the array being passed (1), so a dynamic matrix cannot be passed as a parameter to a subroutine.

**C#:** A subroutine can accept a dynamic matrix. Similar to vectors, it arises here as well: how can we know the size of the array in both directions? The `GetLength` function serves this purpose. Using the parameter `0` refers to the horizontal size, and using parameter `1` refers to the vertical size (lines 3–4).

The two programs are not exactly the same. Their common feature is that they both display the elements of a tic-tac-toe board in matrix form. In the C# version, the main program is not visible. The `tkiir` method prints the received matrix to the screen.

In C++, the procedure prints the elements of a 3x3 matrix, passed as a parameter, one array element at a time.

---



---

### **C# version**
```csharp
static void tkiir(int[,] atvett) {
int i, j, n, m;
n = atvett.GetLength(0);  // Get the number of rows
m = atvett.GetLength(1);  // Get the number of columns
for (i = 0; i <= n - 1; i++) {
for (j = 0; j <= m - 1; j++)
Console.Write(atvett[i, j]);
Console.WriteLine();
}
}
```

---

### **C++ version**
```cpp
void tablakiiir(int atvett[3][3]) {
cout << atvett[2][1];  // Example: print the element at row 2, column 1
}
int main() {
int t[3][3] = { {0, 1, 2},
{1, 2, 1},
{0, 2, 1} };
tablakiiir(t);
}
```

---



# 121

Here is the full translation of the text in the image:

---

## V. PROCEDURES AND FUNCTIONS

### Tasks

1. Create a procedure named *elvalaszto* (separator), which draws a separator line of characters across the entire width of the screen and then leaves a blank line.

2. Modify the previous procedure so that we can specify as a parameter which task number it is, and write it on the screen below the drawn line. The procedure should be suitable for displaying labels such as *3. task*, *b. task*, *3.b. task*.

3. Modify the previous procedure again so that with another parameter we can choose between a full-width and half-width line.

4. For the following tasks, we may use our already existing programs.

5. Create a procedure that displays a 50x50 matrix with row and column numbering. (You may use the code from Task 10 in the *Counter loops* chapter.) The procedure should be named *kep* (image).

Example:
```
00000000001111111111222222222233333333334444444444  
12345678901234567890123456789012345678901234567890  

01  
02  
...  
50
```

6. Modify the previous procedure so that it can display row and column numbering for any square matrix (up to the size that fits on the screen).

7. Modify the previous procedure so that it can display row and column numbering for any size matrix that still fits on the screen.

8. Create a procedure that displays a string of characters in reverse order. The procedure should be called *fordit* (reverse). (It should be called like this: *fordit(szoveg)*.)

9. Create a procedure that displays the letters representing the colors of each pixel in the image, with row and column numbering, from the *kep.txt* file. The procedure should be called *megjelenit* (display), and as parameters, it should receive the three color components of the entire image matrix. (Example: Data storage Task 3, and the call should look like: *megjelenit(r,g,b)*.)

---



# 122
 

---

**FUNCTIONS**  

```
         10       30       20000
          |        |         |
          v        v         v
        length   width      price  
                ↓
         Discounted price  

              16000
```


Functions are procedures that return a single value to the main program. It is often said that the return value of the function is its value. Of course, the function can also perform all the tasks that a procedure would. However, its uniqueness lies in the return value.  

Functions are often illustrated with machines that transform something, similar to how elementary school students imagine machines for certain tasks. The machine’s name, if we’re lucky, refers to the task (e.g., meat grinder), and this can be the function’s name. What we place into the machine is the input parameter (e.g., meat). What comes out of the machine (ground meat) is the result, the return value.  

In textual descriptions, within the function, the return value is marked with the function name (without parameters). The type of the return value is written after the parameter list in textual form, separated by a colon (1).  

In the main program, the return value must be used for something: either printed (8), stored in a variable (6), used with another function call, etc. Using a function as a simple instruction (10) makes no sense and results in an error message, since the return value is created, but nothing is done with it. That would be like placing meat into a meat grinder and then blocking its output.  

The example given introduces functions, as this was part of a final exam task. The task was to determine the amount of discount, where plots 15 meters or narrower or 25 meters or shorter received a 20% discount.  

Writing functions is barely different from writing procedures. At the beginning of the declaration, instead of the keyword `void`, you must specify the return value type (1). The return value itself must be placed after the `return` keyword (3).  

---

 

---

Function `kedv` (h: float, sz: float, a: float) : float  
    If h <= 25 or sz <= 15 then a := 0.8 * a  
    return a  
End of function  

Main program  
    a := kedv(10, 30, 20000)  
    Print: a  
    Print: kedv(20, 30, 30000)  

    // Calling the function directly in print  
    kedv(20, 25, 10000)   // This line is nonsensical, as the function result is not used  

---



# 123



**C# version**  
```csharp
static double kedvez(int h, int sz, double ado) {
    if (sz <= 15 || h <= 25) ado = 0.8 * ado;
    return ado;
}
static void Main(string[] args) {
double a;
    a = kedvez(10, 30, 20000);
    Console.WriteLine(kedvez(20, 30, 30000));
    Console.WriteLine(a);
}
```

**C++ version**  
```cpp
double kedvez(int h, int sz, double ado) {
if (sz <= 15 || h <= 25) ado = 0.8 * ado;
return ado;
}
int main() {
    double a;
    a = kedvez(10, 30, 20000);
cout << kedvez(20, 30, 30000) << endl;
cout << a;
}
```

---

Functions can only return a single value. However, some programming languages allow that this value be a composite type. The original C language does not support this at all. The C++98 version allows returning a record, but not an array. C# can easily return an array as well.

Here's a simple example of this. The `lepes` (step) function takes a 3x3 tic-tac-toe board as a parameter and changes the element in the top-left corner of the array to the value 2 (line 2). Finally, it returns the modified table copy to the main program (line 3), which then modifies the original table.

In terms of coding, the only novelty compared to previous examples is that in the declaration, at the return type, it must be specified that it is a matrix (line 1, after static the int[,]). 

```csharp
static int[,] lepes(int[,] atvett) {
    atvett[0, 0] = 2;
    return atvett;
}
static void Main(string[] args) {
    int[,] t = new int[3,3] { {0, 1, 2},
                              {1, 2, 1},
                              {0, 2, 1} };
    t = lepes(t);
}
```



# 124


---


**Tasks**

1. The factorial of a natural number is the product of the natural numbers from 1 to N. Write a function that receives any natural number as a parameter and returns its factorial.  

2. The first and second elements of the Fibonacci sequence are 1. We always get the next element by adding the previous two elements: 1, 1, 2, 3, 5, 8, 13, ... Create a function that determines the Fibonacci number at the requested position. For example: if we input 7, it returns 13.  

3. For the following tasks, we can use our already existing programs.  

4. A courier receives payment for trips depending on their length, according to the attached table. Write a function that determines the amount of payment based on the given distance!  

| Distance (km) | Payment (Ft) |
|---------------|--------------|
| 1–2           | 500 Ft       |
| 3–5           | 700 Ft       |
| 6–10          | 900 Ft       |
| 11–20         | 1400 Ft      |
| 21–30         | 2000 Ft      |

5. Create a function that, based on the lengths of three line segments, determines whether a triangle can be constructed from those segments. Three line segments can form a triangle only if the sum of the lengths of any two sides is greater than the length of the third side. (Tip: since it’s a decision, what could the return value be?)  

6. Write a function that determines whether any given natural number is prime.  

---



# 125



### SCOPE OF VARIABLES  

Until now, we have created variables in the main program (main) or in functions and procedures. In all cases, they were valid and usable within the program module where they were created. These variables are called **local variables**. These include variables created as parameters of procedures and functions. In the figure, the local variables of the main program are b, f, h, and the local variables of the test1 procedure are a, d, e, f, g.  

If variables are created outside of program modules (main program, functions, procedures), they are accessible from all modules (in the first approximation). These are called **global variables**. In the figure: a, b, c, d. Among these, global variables are truly visible and accessible from every module.  

If a new variable with the same name exists both globally and locally, the local variable will be accessible within that given program module. The local variable will override the global variable. However, this does not mean it overwrites its value. It’s only accessible locally. For example, inside the test1 procedure, the variable a has the value 2, because we are seeing the local variable. Once we exit the procedure, the global variable becomes valid again.  

```c
// Global variables
int a = 1, b = 1, c = 1, d = 1;

void test1(int e, int e2) {
    int a = 2, f = 2, g = 2;
    printf("a: %d, b: %d, c: %d, d: %d, e: %d, f: %d, g: %d\n", a, b, c, d, e, f, g);
    printf("h: %d\n", h); // Will cause an error, h is not declared here
    // end of test1
}

int main() {
    int b = 3, f = 3, h = 3;
    test1(h, f);
    printf("a: %d, b: %d, c: %d, d: %d, f: %d, h: %d\n", a, b, c, d, f, h);
    printf("e: %d, g: %d\n", e, g); // Will cause an error, e and g are not declared here
    return 0;
}
```

Let’s try to follow what the sample program would print out. At first, we get an error message, because in line (5), variable h does not exist, so its value cannot be printed. (Variable h exists only in the main program.) If we comment out line (5), we will still get an error message at line (11), because e and g only exist in the test1 subprogram, and line (11) tries to use them in the main program. If we also comment out line (11), the final output will be:  

```
2, 1, 1, 3, 3, 2  
1, 1, 1, 3, 3  
```

Global variables must be declared before the program modules, mostly in the same way as local variables. In C#, the variable type must also be preceded by the keyword **static**. For example:  
```
static int rszam;
```

# 126



At first glance, global variables are one of the most seductive inventions in the software world. They practically make the use of functions and parameter passing unnecessary, as the data stored in global variables is accessible from both the main and subprograms. In the case of a more complex program, especially if multiple people are writing it, their use requires additional attention and coordination. The clarity of the program code decreases as a result.  

Their use should be reconsidered when dealing with large amounts of data, such as passing large arrays. If local variables are used with value-based parameter passing (see the following chapter), both the original and the copied arrays are created, occupying twice as much space in memory, and exchanging data between variables requires memory operations. It is worth considering how to avoid wasting resources in each case.  

I advise students to use global variables confidently during final exams or competitions. If there is a main data storage array (and there usually is), and its size is large, then a global variable is practical. It is easy to manage, and progress is faster. If every variable had to be local, you would have to remember what value the variable had after the previous use. To transfer values stored in local variables, use parameters and functions.  

---

### Tasks  

1. The following algorithm takes a vector containing whole numbers, rearranges it by placing prime numbers (if any) at the beginning of the vector and composite numbers after the primes. Let’s code this algorithm in the chosen programming language!  

```c
Constant N = 20
Variable A[0..N-1]: array of integers

Procedure Fill
   Loop I from 0 to N-1
      A[I] := RandomInteger(2, 1000)
   End loop
End procedure

Procedure Print
   Loop I from 0 to N-1
      Print A[I]
   End loop
End procedure



Function Prime(A: Integer): Boolean
  I := 2  
  While (I ≤ SquareRoot(A) and (A MOD I ≠ 0))  
    I := I + 1  
  End While  
  Prim := (I > SquareRoot(A))  
End Function  

Procedure PrimePack:
  E := 0  
  V := N - 1  
  S := A[0]  
  While E < V  
    While (E < V and not Prime(A[V]))  
      V := V - 1  
    End While  
    If E < V then  
      A[E] := A[V]  
      E := E + 1  
      While (E < V and Prime(A[E]))  
        E := E + 1  
      End While  
      If E < V then  
        A[V] := A[E]  
      End If  
      V := V - 1  
    End If  
  End While  
  A[E] := S  
End Procedure  

Program PrimePackager:
  Fill  
  Print  
  PrimPack  
  Print  
Program end.  
```
# 127
-----
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <cstdlib>
#include <ctime>

const int N = 20;
int A[N];

// Fill procedure: fills the array with random integers between 2 and 1000
void Fill() {
    std::srand(std::time(0));
    for (int i = 0; i < N; ++i) {
        A[i] = rand() % 999 + 2;  // random integer between 2 and 1000
    }
}

// Print procedure: prints the array elements
void Print() {
    for (int i = 0; i < N; ++i) {
        std::cout << A[i] << " ";
    }
    std::cout << std::endl;
}

// Prime function: checks if a number is prime
bool Prime(int a) {
    if (a < 2) return false;
    int limit = static_cast<int>(sqrt(a));
    int i = 2;
    while (i <= limit && (a % i != 0)) {
        i++;
    }
    return (i > limit);
}

// PrimePack procedure: reorders the array so that primes are at the start
void PrimePack() {
    int E = 0;
    int V = N - 1;
    int S = A[0];

    while (E < V) {
        while (E < V && !Prime(A[V])) {
            V--;
        }
        if (E < V) {
            A[E] = A[V];
            E++;
            while (E < V && Prime(A[E])) {
                E++;
            }
            if (E < V) {
                A[V] = A[E];
            }
            V--;
        }
    }
    A[E] = S;
}

// Main program
int main() {
    Fill();
    std::cout << "Original array:\n";
    Print();

    PrimePack();

    std::cout << "Array after PrimePack:\n";
    Print();

    return 0;
}
```




# 128
 

We can use our already existing code snippets for the following tasks.  
For the data read in, create a global array and store the number of rows read in a global variable as well. Create one procedure for reading the data from the file (name: beolvas), and another one for displaying the data. If it is necessary to transform the data, perform that within a function. If data needs to be passed between modules in addition to the read-in data, use local variables, functions, and parameter passing. In short, all larger operations should be implemented as separate procedures or functions.  

2. In the file kep.txt, each line contains the data of one pixel in RGB code. The image consists of 50x50 pixels.  
a. Read from the file into a suitable data structure the RGB code of each pixel!  
b. For testing purposes, display the image matrix as characters on the screen! Use a procedure for this, so that it only appears once in the code. Call this procedure: megjelenit() (display). (You can use the code written for exercise 3 in the chapter titled "Data storage in arrays"; extend it with the recognition of the black color. The black dots should be represented by the character F in the image matrix.)  

*Sample detail for the task:*  
```
Minta részlet a feladathoz (Sample part for the task)
000000000011111111112222222222333333333344444444445
012345678901234567890123456789012345678901234567890
08 ........PPPPPPPPPP................................
09 ........PPPPPPPPPP................................
10 ........PPPPPPPPPP................................
11 ........PPPPPPPPPP................................
12 ........PPPPPPPPPP................................
13 ........PPPPPPPPPP................................
14 ........PPPPPPPPPP................................
15 ........PPPPPPPPPP..............ZZZZZZZZZZZZZZZZZZ
16 ........PPPPPPPPPP..............ZZZZZZZZZZZZZZZZZZ
17 ........PPPPPPPPPP..............ZZZZZZZZZZZZZZZZZZ
18 ........PPPPPPPPPP..............ZZZZZZZZZZZZZZZZZZ
19 ........PPPPPPPPPP..............ZZZZZZZZZZZZZZZZZZ
20 ........ZZZZZZZZZZZZZZZZZZZZZZZZKKKKKKKKKKKKKKKKKK
```

c. Create a frame around the image, 3 pixels wide, in black color! Create the frame in such a way that the size of the image does not change! The RGB code for black is (0, 0, 0). Use a procedure for creating the frame, called: keret() (frame).  

d. For testing purposes, display the image matrix as characters on the screen again! Use the megjelenit() procedure from part b) for this.  

 

# 129



### PARAMETER PASSING  

#### Passing by value  

The parameter passing method we have learned in the Procedures chapter is called passing by value, because only the value of the variable is transferred from the main program to the subprogram.  

During program execution, a memory area is allocated for the variable found in the main program (variable 'a' in memory block 0). Then, when the procedure test1 is called, another memory area is allocated (variable 'x' in memory block 3 for local variables). During the procedure call, the value of the variable from memory block 0 is copied into memory block 3. From this point on, the two variables live completely independent lives. Modifying x will not change a.  

At the end of the procedure, the variables belonging to that procedure cease to exist.  

We can also call the procedure by giving a concrete value instead of a variable as a parameter (for example: test1(27)). In this case, a memory space will be allocated for the subprogram's variable and the given numeric value (27 in the example) will be placed there.  

In most cases, this type of parameter passing is suitable for the purpose, so it is the default. Coding is done the way we learned in previous chapters.  

The drawback of this method is that it takes up twice the memory space than the variable itself. This is especially significant for large memory-demanding variables, such as large arrays.  

The above example algorithm would output: 1, 1, 2, 1.  

---

#### Passing by reference (address passing)  

In reference passing, the same memory area is assigned to the variable in both the main program and the subprogram. So it only appears as if there are two copies of the data, but in reality, it’s the same memory area with two different names.  

When the program starts running, the variable in the main program is created first, with a memory area allocated to it (variable 'a' in memory block 3). Then the subprogram receives a variable name (x), which points to this same memory area. So, it works like a pair of aliases. At any given time, the value of x and the value of a will be the same. If either is modified, the changes will appear in the shared memory area, meaning both variables will also affect the variable’s value used in the main program.  

That’s why this method is called passing by reference or passing by address, because the subprogram refers to the same memory location where the main program’s variable resides.  

There is no point in calling `test1(27)` by reference, since this would try to reference a constant value, not a variable. This would result in an error message.  

The algorithm for this example would output: 1, 1, 2, 2.  

In C++ code, when passing a parameter by reference, the variable name in the subprogram is preceded by the `&` symbol. The procedure call in the main program happens exactly the same way as in value passing. The `C++` program in the illustration shows how `a` and `b` both point to memory locations. The subprogram only uses variable names without prefixes; we don’t put `&` before them when calling.  

In C#, the type of the variable in the parameter list is preceded by the `ref` keyword. When calling the procedure, the `ref` keyword also needs to be used before the variable names. Inside the subprogram, we only use the variable names without the `ref` keyword.  

---

**C# version**  
```cs
 static void csere(ref int egyik, ref int masik)  
 {  
 int buff = egyik;  
 egyik = masik;  
 masik = buff;  
 }  
 static void Main(string[] args)  
 {  
 int a = 5, b = 4;  
 csere(ref a, ref b);  
 }  
```

**C++ version**  
```cpp
 void csere (int &egyik, int &masik)  
 {  
 int buff = egyik;  
 egyik = masik;  
 masik = buff;  
 }  
 int main()  
 {  
 int a = 3;  
 int b = 4;  
 csere(a, b);  
 }  
```

---

### Tasks  

1. In the main program, request two integers from the user and store them in variables `a` and `b`. Write a function called `csere` (swap) that exchanges their values. After the swap, print the contents of the variables. You can find help in section 2.e. of the Arrays chapter.  

2. Rewrite the previous chapter’s task without using global variables, using passing by reference instead.  

3. If using C#, rewrite the previous chapter’s task without global variables as well, using only passing by value.  

4. Solve exercise 1 without using a helper function. The solution can be found in the footnote.  




# 131

Here’s the full translation of the provided page from Hungarian to English:

---

**V. PROCEDURES AND FUNCTIONS | 131**

## RECURSION

### Definition

The word recursion means containing or referring to oneself. Based on this, under recursion, we understand those procedures or functions that refer to themselves.

Although in most literature the previous definition appears in some form, I would slightly refine it as: *themselves in another instance.*

Let’s study the attached diagram, where with a recursive algorithm we look for the greatest common divisor. Let’s follow its operation. At the end of lines 3 and 4, it is clear that the function calls itself again with new input values (the program continues there).

---

### Operation

Let’s see how recursion works through the example shown earlier!

We are looking for the greatest common divisor of 75 and 50, so the first call of the function will receive these two parameters. Out of the three branches of the conditional, the last condition (4) is met. In this branch, control continues, and a new function call follows with parameters 75-50 and 50. A new instance of the function is created, where the middle:

**Sequential function call** | **Sequential return**
:----------------------------|:------------------------
The diagram on the left shows the chain of function calls, and on the right, the chain of returns.

---

**Function lnko(a, b : integer numbers) : integer**  
1) Function lnko(a, b : integer numbers) : integer  
2) if a = b then lnko := a  
3) if a < b then lnko := lnko(a, b - a)  
4) if a > b then lnko := lnko(a - b, b)  
5) End of function  



# 132



The condition in the branch is fulfilled, so execution continues in this branch, where another function call follows with parameters 25 and 50-25. The function now has a third instance, where the first line checks the condition, finds it true, so there is a return value of 25, and no further function calls.

The third instance of the function was created by the second instance, so the return value of the third instance is received by the second instance. The function call is replaced at this point, and lo and behold, the second function also has a return value.  
The second instance was created by the first instance, so the return value of the second instance is taken over by the first instance. The replacement occurs at the location of the function call. In this way, the first function also has a return value, which ultimately is passed back to the main program. The already used function instance ceases to exist after the return of the parameter.

The operation described shows that during the phase of function calls, the currently not yet finished function instances need to be stored for later use. This can be memory-intensive in the case of many calls.

---

### Structure

Until the final exam, you have not been required to write a recursive algorithm on your own, but according to the expectations, it can also happen. So let's take a look at how a recursive function is structured.

The function needs to call itself, so there will be at least one part that contains a recursive call. In the example, there are two: at the end of lines (3) and (4).

The function must eventually end, so there will be a part where the function gives a specific return value (end of line 2 in the example).

There will be a base condition (in the example: a = b), which helps determine whether the series of recursive calls has come to an end.

There will be a branching based on the base condition, with one branch leading to the function call, and the other branch providing a specific value assignment. Of course, before the value assignment and function call, further operations can also occur.

Finally, there needs to be an operation that moves every recursive function instance closer to the base condition. In the example, this is a = a - b, and b = b - a in lines (3) and (4) of the function calls.

If we write the recursive subroutine incorrectly, it may happen that it ends up calling itself infinitely. That means a large number of instances will be created, each taking up some memory, and the program will end in an error due to running out of memory. The program may even appear to do nothing for a long time, and then eventually crash.

---



# 133

 

### Recursive and Iterative Forms

Recursion is a type of repetition that seems to be a worthy competitor to loops. When we solve a task without using recursion and instead use loops, we talk about the iterative form.

A problem can often have both recursive and iterative solutions. The iterative solution generally runs faster and uses less memory. The recursive form is sometimes shorter and can be easier for a person to understand.

The use of recursive functions does not require new coding knowledge.  
 
---

### Tasks

1. **Write a function to calculate the greatest common divisor (GCD)!**  
   Let’s try it out!  

   ```
   Function gcd(a, b: integers) : integer
       if a = b then gcd := a
       if a > b then gcd := gcd(a, a - b)
       if a < b then gcd := gcd(b - a, b)
   End function
   ```

2. **Write a function to calculate the least common multiple (LCM)!**  
   Let’s try it out!  

   ```
   Function lcm(a, b: integers) : integer
       lcm := a * b / gcd(a, b)
   End function
   ```

3. **The factorial of a natural number N is the product of all natural numbers from 1 to N.**  
   Write a recursive function that takes a natural number as a parameter and returns its factorial.

4. **The first and second elements of the Fibonacci sequence are both 1.**  
   Each following element is obtained by adding the previous two elements:  
   1, 1, 2, 3, 5, 8, 13, ...  
   Create a recursive function that calculates the Fibonacci number at a given position.  
   For example, if we input 7, it returns 13.

---

 

# 134

 

### MODULAR PROGRAMMING AND TESTING  

In the previous sections, we saw that breaking down a task into modules using procedures and functions makes the code more transparent and shorter, divides the work into manageable parts, and also makes testing easier.  

The only question is: how can we break down a complex task into modules, and how do we fit them back together afterward?  

---

### Breaking down into modules by highlighting common parts  

First, it is worth observing the partial repetitions that can be found in the task. In the accompanying figure, the tasks are the following: simplifying a given fraction, multiplying two fractions, and adding two fractions. For this task, we have the greatest common divisor (gcd) function and the least common multiple (lcm) function available.  

The figure shows that fractions need to be simplified after each operation. Therefore, it would be a waste to write this simplification repeatedly. Let's write a function called `simplify` and use it in all three cases.  

The `simplify` function uses the gcd function, and the addition function uses the lcm function. This way, we can create a “function map” of our task, a diagram showing which function uses which other functions. The figure shows in what order the functions need to be placed in the code. (Before calling a function, it must be declared.)  

---

**Examples in the diagram:**
1. Simplification:  
   - 24/32 = 3/4  
   - 24/6 = 4 (if the fraction equals an integer)

2. Fraction multiplication:  
   - 24/32 * 12/15 = 288/480 = 3/5  
   - 24/32 * 8/3 = 192/96 = 2  

3. Fraction addition (using the lcm function):  
   - 24/32 + 8/3 = 72/96 + 256/96 = 328/96 = 41/12  
   - 22/4 + 27/6 = 66/12 + 54/12 = 120/12 = 10  

---

In summary: with this method, we highlight the common parts into separate independent functions (procedures).

---



# 135



### Breaking down the task into modules

A single task on its own can be too complex to write in one piece or even to test.  

A general piece of advice is to keep things that are closely related in the task text together and to break them apart along less related lines.  

Let's look at the following example task:  

> The municipality wants to levy a land tax. The tax is calculated in Fabatka units. For plots of 700 square meters or less, the tax is 51 Fabatka per square meter. For larger plots, for the first 700 square meters, the tax is also 51 Fabatka per square meter. For the area between 700 and 1,000 square meters, the tax is 39 Fabatka per square meter. For the area above 1,000 square meters, the tax is not calculated by square meter; instead, the total amount is 200 Fabatka more than the tax for exactly 1,000 square meters. Plots that are 15 meters wide or less, or 25 meters long or less, are entitled to a 20% tax discount. The tax amount must be rounded to the nearest 100 Fabatka (e.g., 6,238 should be rounded to 6,200; 6,586 to 6,600). Write a function that determines the tax for any plot, given the dimensions of its sides.  

By reading the task multiple times carefully, we can realize that the text is divided into three parts:  
1. The largest part deals with the calculation of the tax.  
2. Next comes determining the discount.  
3. Finally, rounding off.  

Based on this, it is useful to draw a map of how the functions build on each other, indicating parameters and returned values. With this help, we can easily declare the functions and determine their order in the code (points 1-3):  

1. Function `kerekít(fab : integer)` (round)  
2. Function `kedv(h: integer, sz: integer, p: integer)` (discount)  
3. Function `adó...` (tax)  
4. ...  
5. `adó = kerekít(kedv(hossz, szél, f))`  
6. End of functions  
7. Main program  
8. Output: `adó(40, 20)`  

If we write the functions separately, we will somehow need to manage calling them from one another. This can be done by nesting functions within each other, that is, by calling a previously defined function inside another one (step 5).  



# 136

 
**Modular and functional testing**

Breaking down into modules generally greatly simplifies testing as well. Let's calculate how many test cases are needed based on the principle of full coverage testing, breaking it down into necessary modules, and how many are combined in the example of a land tax calculator.

| giver         | discount      | rounded   |
|---------------|---------------|-----------|
| under 700 m²  | length        | up        |
|               |               | down      |
| 700–1000 m²   | width         | up        |
|               |               | down      |
| over 1000 m²  | both          | up        |
|               |               | down      |
|               | none          |           |

1) Output: round(6238)  
2) Output: round(6586)  
3) Output: discount(20, 20, 1000)  
4) Output: discount(30, 10, 1000)  
5) Output: discount(20, 10, 1000)  
6) Output: discount(30, 20, 1000)  
7) Output: tax(30, 20)  
8) Output: tax(40, 20)  
9) Output: tax(40, 30)  

Testing the rounding function requires two test cases, as we can round either up (2) or down (1). The function calculating the discount can be tested based on four cases: discount by length (3), discount by width (4), discount by both (5), and no discount (6). Finally, the tax function can be covered by three cases: under 700 m² (7), between 700 and 1000 m² (8), and over 1000 m² (9). Adding the tests of the function combinations, we get 2 + 4 + 3 + 1 = 10 test cases in total.

If we had left the task as is (or only tested them together), the number would be 2 * 4 * 3 = 24, since, for example, a plot under 700 m² could be discount-eligible due to length, width, both, or neither. And all these could round up or down. (See diagram on the left-hand side.) This approach would not only be more time-consuming, but also redundant, as by looking at the final outcomes, we wouldn't know in advance whether, for instance, for plots over 1000 m² with both discounts applicable, the tax will be rounded up or down in the end.

When testing modules separately, independent of other modules, we talk about *module testing*.

However, module testing alone is sometimes not sufficient. On one hand, complete and thorough testing is rarely done. On the other hand, module integration errors can also arise. Therefore, a full coverage test of the entire system is usually needed. The combined testing of interconnected modules is called *functional testing*.

As we have seen, functional testing means far more tests, which would require careful planning and selection. All of this is very time-consuming...

 



# 137
 

Therefore, generally a few (in extreme cases only one) characteristic test cases with typical input parameters are selected, and only these are used to perform the functional test.  

In the example of the tax calculator, any of the lines (7)-(9) can be chosen for functional testing. The difference compared to modular testing is that here we already test the embedding of the functions into each other, while in modular testing we only test the calculation of the discount and rounding without errors.  

Some functional tests combined with very thorough module tests provide acceptable operational safety in most cases.  

Naturally, during the exam, there will not be time to plan testing so thoroughly. We can usually manage the module tests during the writing of the modules, and the functional test is generally completed with one or two tasks after the modules are finished.  

Companies often automatically test continuously developed software. Both module and functional tests are run periodically by a program that sends error messages to developers in case of failure. (Due to continuous development, modules may change.) This saves a significant part of the expensive labor hours spent on testing.  

Finally, it is worth noting that software errors (later fixed by patches) are partly due to inadequate thoroughness of testing. On the one hand, the tight deadlines, and on the other hand, the attitude that the client does not pay for testing. Therefore, developers generally do not like to test.  

---

**Tasks**  

1. The local government will levy a property tax. The tax is calculated in Fabatkas. For lots of 700 square meters and smaller, the tax is 51 Fabatkas per square meter; for larger lots, the first 700 square meters are taxed at 51 Fabatkas each, the area between 700 and 1000 square meters at 39 Fabatkas per square meter. For areas exceeding 1000 square meters, no price is defined per square meter; instead, a flat rate of 200 Fabatkas is paid. Owners of plots that are 15 meters or narrower, or 25 meters or shorter, receive a 20% tax discount. In determining the tax, 100 Fabatkas rounding must be used (e.g., for 6238 use 6200, for 6586 use 6600). Write a function that determines the tax for each plot based on the side lengths. Break it down into multiple subtasks and functions.  

2. Perform module testing for the previous task based on full coverage. The test cases should be noted as comments in the main program.  

3. Perform functional testing for task 1. The test cases should be noted as comments in the main program.  

4. Write a program that asks for the numerators and denominators of two common fractions. The program should reduce the fractions individually. It should display the fractions in a simplified form and show their values. The program should multiply and add the two fractions and display the results in reduced form and, if possible, as whole numbers. You can use the greatest common divisor function described in the Recursion chapter or the least common multiple function. Move repeated parts of the code into functions.  

5. Perform module testing for the previous task based on full coverage. The test cases should be noted as comments in the main program.  

6. Perform functional testing for task 4. The test cases should be noted as comments in the main program.  

---

### SUMMARY  

#### Modules  

The division of tasks, algorithms, and programs into parts is done with the help of modules. We do this in order to:  

- Avoid code duplication, making the source code shorter and more readable.  
- Make the individual tasks to be solved more manageable and clearer.  
- Allow the work to be easily shared among multiple people.  
- Make testing and debugging simpler.  

Procedures and functions are independent modules. In other words, we can say that procedures and functions define the rough structure of the program.  

 

# 139



**Procedures, functions**  

A procedure is a module that does not return a value to the main program. A function does return a value.


### C# version:

**Procedures and functions (C#):**
```csharp
static double fuggveny(int sorszam){
    ...
    return valami;
}

static void eljaras(){
    ...
}

static void eljaras2(int v, int f){
    ...
}

static void Main(string[] args){
    ...
    eljaras();
    eljaras2(10,5);
    a = fuggveny(10);
}
```

### C++ version:

**Procedures and functions (C++):**
```cpp
double fuggveny(int sorszam){
    ...
    return valami;
}

void eljaras(){
    ...
}

void eljaras2(int v, int f){
    ...
}

int main(){
    ...
    eljaras();
    eljaras2(10,5);
    a = fuggveny(10);
}
```

### Passing parameters

- **By value:** The subprogram makes a copy of the variable passed by the main program, so the operation of the subprogram does not affect the variable’s value in the main program.

- **By reference (by address):** The main program and the subprogram share the same memory area for the affected variable, so the subprogram modifies the content of the variable in the main program. Parameters of the subprogram can only be given as variable names. The following code snippets show how passing by reference works:


 


**Passing parameters by reference (C#):**
```csharp
static void csere(ref int egyik, ref int masik){
    int buff = egyik;
    ...
}

static void Main(string[] args){
    int a = 3;
    int b = 4;
    csere(ref a, ref b);
}
```

---



**Passing parameters by reference (C++):**
```cpp
void csere(int &egyik, int &masik) {
    int buff = egyik;
    ...
}

int main(){
    int a = 3;
    int b = 4;
    csere(a, b);
}
```


# 140
 

### Scope of variables

- **Global:** Valid throughout the entire program. Declared outside of procedures.  
- **Local:** Valid only within the currently running instance of the procedure. Declared inside the procedure.

---

### Recursion

Procedures or functions that refer to themselves (to another instance of themselves).

---

