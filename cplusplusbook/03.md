

**III. CONTROL STRUCTURES**  

**SEQUENTIAL EXECUTION**  

In programming, the order in which instructions are issued generally matters. If we issue the same instructions in a different order, the program may work differently or may not work at all. For example, the instruction 1. "move forward 5 steps" and 2. "move left 2 steps" can get us to the same position, provided we are in a large, empty space and can switch their order without issues. However, the situation changes if there is a wall one step to the left from our position.  

By using **control structures**, we can decide which instruction should follow which one during the execution of the program. Therefore, it can happen that instructions are not executed in the exact order they appear in the code.  

The execution of instructions in the order they appear in the code, in a step-by-step manner, is called **sequential execution**.  

In our short programs so far, we have followed sequential execution, just without explicitly naming it.  

---

**CONDITIONAL BRANCHING - BASICS**  

*Introduction*  

If, depending on a condition, the program can continue in multiple ways, we use **branching**. Branching structures are also called **selection structures**.  

The condition always has a **logical value**, meaning it is either **true** or **false**. Most of the time, conditions are given in the form of **comparisons**. For example, the condition *a > 0* can clearly determine, in a specific situation, whether it is true or false.  

*27 In mathematical terms: branching is used to create case separation.*  
*28 In mathematical terms: relations.*

Here’s the full translation of the provided text from Hungarian to English:

---

**In a flowchart, conditional branching is represented by a diamond shape with a vertex.**  
Inside the diamond, we write the condition, and on the arrows leaving it, we write the letters i (true) and h (false). This indicates which way the program continues: along the true branch or the false branch.  
**Program branches** can meet again in another place in the flowchart, at a **junction point**. The junction point is marked with a small circle.

---

### One-way branching

We can talk about one-way branching if only a true branch is created in the program.  

The structure of one-way branching can be described in sentence form as follows:  

```
If <condition> then <instructions>  
End of branching
```

**Interpretation:** if the condition is met, then the instructions after "then" are executed. After that, the program continues after the "end of branching".  
If the condition is not met, program execution continues immediately after the "end of branching".  

If there is only one instruction after "then," the "end of branching" can be omitted.  

Let’s consider the following example: calculate the absolute value of a number entered. If the number is not negative, we don't have to do anything, just print it out. Thus, we can define the condition as: `a < 0`.  
The complete algorithm can be seen in the left column below:  

| **The algorithm of the example**               | **Branching coded in C languages**         |
|-----------------------------------------------|-------------------------------------------|
| Input: a                                      | if (a < 0)                                |
| If a < 0 then a := (-1) * a                   | &nbsp;&nbsp;a = (-1) * a;                |
| Output: a                                     |                                           |

**Condition**                    | **Instruction in the true branch**  

---

The above branching coding looks like the right side in all C-like languages. The condition must always be placed between parentheses. The instruction in the true branch (for now, only one instruction) is written after it, separated by a space.  

---

29. The use of the term might sound odd since how can one branch in only one direction? However, in professional literature, this structure is often called this way, since there is no false branch.

 
65
 
 

---

### Branching in Two Directions  

We talk about two-way branching if, depending on one condition, the program needs to continue in two different ways. So we want to use the false branch.  

The syntax:  

```
If <condition> then <instructions1>
  else <instructions2>
End of branching
```  

**Interpretation**: if the condition is met, instructions1 will be executed; otherwise, instructions2 will be executed. After executing the instructions, the program continues after the End of branching.  

**Example**: negative numbers do not have a square root among real numbers. Let's write a program that asks the user for a number before computing the square root, and in the case of a negative number, it displays that the root cannot be taken. In the case of zero or a positive number, it proceeds to compute the square root. The algorithm of the solution is shown here:  

```
Input: a
If a < 0 then Output: "The operation cannot be performed."
  else Output: square_root(a)
End of branching
```  

In C-like languages, compared to what we learned earlier, the coding expands with an `else` statement, after which we give the instructions for the false branch (for now, one statement each).  

In the image below and in the previous algorithm, you can see that I started on certain lines further inward. The program works without this as well; its purpose is solely to improve readability. Such formatting may be expected at workplaces and in schools, but it cannot be required during an advanced-level graduation exam.  

**C# version**:  
```csharp
int a;
a = Convert.ToInt16(Console.ReadLine());
if (a < 0)
  Console.WriteLine("The operation cannot be performed.");
else
  Console.WriteLine(Math.Sqrt(a));
```  

**C++ version**:  
```cpp
int a;
cin >> a;
if (a < 0)
  cout << "The operation cannot be performed.";
else
  cout << sqrt(a);
```

Here is the verbatim English translation of the provided Hungarian text:

---

### Comparison  

From the following table, it can be read what relational signs we can use when giving conditions.  

In C languages, = means let it be equal. Equality, as a comparison, received the symbol == so that it cannot be confused with let it be equal and the equal to expressions.  

It is also common to code not equal. In algorithmic languages (and in many other programming languages, as well as in Excel), the logical less or greater is coded with the symbol <>. In C languages, the ! symbol is the sign of negation (not), so the not equal sign is !=.  

| Name of operation        | C languages | Algorithm   |
|--------------------------|-------------|-------------|
| greater than             | a > b       | a > b       |
| less than                | a < b       | a < b       |
| greater than or equal to | a >= b      | a ≥ b       |
| less than or equal to    | a <= b      | a ≤ b       |
| equal to                 | a == b      | a = b       |
| not equal to             | a != b      | a ≠ b       |

---

### Tasks  

1. Request a real number from the user and determine its absolute value. If you cannot do it otherwise, ask for help from the worked-out solution.  

2. Write a program that, before taking the square root, asks the user for a number, and if the number is negative, displays that the root cannot be taken. In the case of zero or a positive number, perform the square root operation. If you cannot do it otherwise, ask for help from the worked-out solution.  

3. Ask the user for the number of ships visible from the lighthouse. If this value is greater than three, display "Heavy tower" on the screen; otherwise, do not display anything.  

4. Ask the user for two numbers, which will be the numerator and denominator of a common fraction. Decide whether the entered fraction can be expressed as an integer; if so, display its integer value, if not, display "Cannot be expressed."  

5. Write a program that asks for a 3-digit positive integer from the keyboard and determines whether it is an Armstrong number. A 3-digit Armstrong number is a number where the sum of the cubes of its digits equals the number itself, for example, 371 = 3³ + 7³ + 1³. Display the result on the screen!  

---
Here is the full verbatim English translation of the provided page:  

---



**CONDITIONAL BRANCHING – MORE COMPLEX CASES**  

### Using a block of instructions  

When thinking in C languages, sometimes we would like to place multiple instructions in the false branch of a conditional statement. How will the compiler know where the end of the false branch is, and after that, where the end of the branching is? In C languages, there is no "end of branching" instruction like in sentence-like descriptions.  

In C languages, we use **instruction blocks** when we want to provide multiple instructions in one branch of a control structure, in our case, in the false branch. The instruction block groups the instructions together. Its symbol is the pair of curly brackets `{}`, between which we write the instructions.  

In the example code, in the branching (lines 15–20), we use an instruction block in the false branch. In line (20), the closing curly bracket marks the end of the false branch starting from line (17), containing all instructions executed in that branch (line 21). In the true branch (line 15), we do not need an instruction block, since we only execute a single instruction.  

```c
14 int a, b, c, k;  
15 if (k == 3) a = 1;  
16 else {  
17     a = 0;  
18     b = 0;  
19     c = 0;  
20 }  
21 k = a + b + c;  
```  

### Branching in multiple directions  

It may happen that more than two cases need to be separated. In this case, the branches will be nested into each other. This simply means that with the first branching we select between two possibilities, and then in one or both branches, we place further branchings.  

For example: let’s decide about a number, whether it is positive, negative, or zero. This is a three-case situation, which we cannot solve with a single conditional branching. First, we separate between zero and not-zero. If it is equal to zero (line 16), we can write that it is zero, and there is nothing more to do. If it is not equal to zero (line 17), another branching will follow inside the previous one, according to lines (18)–(19), whether it is greater than zero or not. On line (18), we can write that it is positive. On line (19), we can write that it is negative.  

In C language coding, instruction blocks must also be used in lines (17) and (20), because in line (18) and in the `else` (19) branch we count on two instructions, even though it is one single control structure.  

---

Here is the full verbatim English translation of the provided page:  

---



**Nesting branches within branches – algorithm**  

**Algorithm for nesting branches within branches**  

16) If a = 0 then print: '0'  
17) else  
18) If a > 0 then print: '+'  
19) else print: '-'  
20) end of branch  
21) end of branch  

```c
16 if (a==0) ki='0';  
17 else {  
18     if (a>0) ki='+';  
19     else ki='-';  
20 }  
```  

By nesting multiple branches within each other, we can create branching in three or more directions as well. If the Reader truly understands this topic, they will be able to answer the following questions: How many branches are needed to be nested in order to create a five-way branching? And what about in the case of n branches? The answer can be found in the footnote. 30  

---

### Compound conditions  

Compound conditions consist of partial conditions. For example, “smaller than 7 and greater than 0” is a compound condition made up of two partial conditions: “smaller than 7” and “greater than 0.”  

Both compound conditions and partial conditions can only have values that are either true or false, so we are dealing with logical expressions.  

Creating compound conditions from partial conditions is important, because the `if` statement can only accept a single logical (true/false) value. If we have multiple conditions, it is not sufficient to simply write them after one another, as that would result in multiple logical values.  

With the help of logical operations, we can combine multiple logical values into one, thus connecting partial conditions into a compound condition.  

---

### Logical AND  

| A     | B     | A ∧ B  |  
|-------|-------|--------|  
| true  | true  | true   |  
| true  | false | false  |  
| false | true  | false  |  
| false | false | false  |  

In the case of a logical AND operation, the result is only true if **all partial conditions** are true. In every other case, it is false.  

---

_Footnote: 30 — 4 branches for 4 directions, n-1 branches for n directions._  

---



68  Here is the full verbatim English translation of the provided page:  

---



**Nesting branches within branches – algorithm**  

**Algorithm for nesting branches within branches**  

16) If a = 0 then print: '0'  
17) else  
18) If a > 0 then print: '+'  
19) else print: '-'  
20) end of branch  
21) end of branch  

```c
16 if (a==0) ki='0';  
17 else {  
18     if (a>0) ki='+';  
19     else ki='-';  
20 }  
```  

By nesting multiple branches within each other, we can create branching in three or more directions as well. If the Reader truly understands this topic, they will be able to answer the following questions: How many branches are needed to be nested in order to create a five-way branching? And what about in the case of n branches? The answer can be found in the footnote. 30  

---

### Compound conditions  

Compound conditions consist of partial conditions. For example, “smaller than 7 and greater than 0” is a compound condition made up of two partial conditions: “smaller than 7” and “greater than 0.”  

Both compound conditions and partial conditions can only have values that are either true or false, so we are dealing with logical expressions.  

Creating compound conditions from partial conditions is important, because the `if` statement can only accept a single logical (true/false) value. If we have multiple conditions, it is not sufficient to simply write them after one another, as that would result in multiple logical values.  

With the help of logical operations, we can combine multiple logical values into one, thus connecting partial conditions into a compound condition.  

---

### Logical AND  

| A     | B     | A ∧ B  |  
|-------|-------|--------|  
| true  | true  | true   |  
| true  | false | false  |  
| false | true  | false  |  
| false | false | false  |  

In the case of a logical AND operation, the result is only true if **all partial conditions** are true. In every other case, it is false.  

---

_Footnote: 30 — 4 branches for 4 directions, n-1 branches for n directions._  

---

Here is the full verbatim English translation of the provided page:  

---



For two partial conditions (A and B), the attached table is valid. However, it is important to know that this operation can be applied to more than two partial conditions based on the previous explanation and definition.  

For example: let’s check the correctness of a number provided by the user. It should be considered correct if its value falls between 1 and 8, including the boundaries. We can only print the message "Good" if both partial conditions a ≥ 1 and a ≤ 8 are true. In this case, we need to use the AND operation (line 16).  

The standard symbol for the AND operation in algorithmic language is: ^. However, often the words AND or the English AND are used instead, since typing the ^ character can be problematic. In C languages, we use the && symbol for this purpose. ³¹ (16).  

---

### Logical OR  

| A     | B     | A ∨ B  |  
|-------|-------|--------|  
| true  | true  | true   |  
| true  | false | true   |  
| false | true  | true   |  
| false | false | false  |  

In the case of a logical OR operation, the result is true if **any of the partial conditions** is true. This includes situations where one or more partial conditions are satisfied. In other words, the operation is false **only if all partial conditions are false**. In every other case, the result is true.  

For two partial conditions (A and B), the attached table is valid. However, it is important to know that this operation can also be applied to more than two partial conditions based on the previous explanation and definition.  

For example: let’s check the correctness of a number provided by the user. In this case, we print the message "Bad" if the number is less than or equal to 1, or greater than or equal to 8. The "Bad" message must be printed if either of the two partial conditions is satisfied. So in this case, we need to use the OR operation (line 18).  

The standard symbol for the OR operation in algorithmic language is the ∨ character. However, often the OR or the English OR words are used instead. In C languages, the `||` symbol is used. ³² (18).  

---

_Footnotes:_  
³¹ The single ampersand & symbol in C languages is used for the bitwise AND operation.  
³² The single pipe | symbol in C languages is used for the bitwise OR operation.  

---

Here is the full English translation of the page you provided:  

---



## Logical NOT  

| A   | ¬A   |
|-----|------|
| true  | false |
| false | true  |

The logical NOT operation simply turns truth into falsehood and falsehood into truth. In algorithm description language, it is represented by the ¬ symbol. If writing this symbol is problematic, the words NOT or NEM are used instead. The opposite (negation) of `a > 1` is `a <= 1`; for example, if a number greater than 1 is given, the word "good" will be displayed.  

### Compound conditions – algorithm  

16) If a >= 1 AND a <= 8 then  
17) Print: "good"  
18) If a <= -1 OR a >= 8 then  
19) Print: "bad"  
20) If NOT (a <= 1) then Print: "good"  

### Compound conditions – in C language  

| Line | Example in C                              |
|------|------------------------------------------|
| 16   | `if (a >= 1 && a <= 8)` <br> `printf("good");`   |
| 18   | `if (a <= -1 || a >= 8)` <br> `printf("bad");`   |
| 20   | `if (!(a <= 1))` <br> `printf("good");`   |

It is possible to connect multiple conditions using logical operations. Sometimes a complex chain of logical operations is formed, so it’s important to know the **order of operations**:  
Parenthetical expression > NOT > AND > OR  

In practice, however, I have experienced that it’s often advisable to enclose every sub-condition in parentheses, because sometimes the compiler does not interpret the operations the same way as the developer intends.  

Similarly, it can be worthwhile to subject chains of logical operations to simplification procedures, or break them down into multiple branches. The AND operation can be replaced by nested branches, and the OR operation can be replaced by sequentially applied branching.  

---

**Footnote:**  
33 The possibilities of simplification are omitted here due to space constraints. In the appropriate literature, you can find a systematic approach to simplification procedures for logical functions.  

---

Here’s the full English translation of the page you provided:

---



### Exercises  

1. Ask the user for a real number and display whether it is positive, negative, or zero. If not used elsewhere, apply the result to a previously developed task.  

2. Ask the user for two integers and display them in ascending order. In the case of equality, display the number only once.  

3. A courier receives payment based on the distance traveled according to the table below. Ask the user for a distance between 1 and 30 km, and determine how much payment they receive for it.  

| Distance   | Payment   |
|------------|-----------|
| 1 – 2 km   | 500 Ft    |
| 3 – 5 km   | 700 Ft    |
| 6 – 10 km  | 900 Ft    |
| 11 – 20 km | 1400 Ft   |
| 21 – 30 km | 2000 Ft   |

4. Write a program that asks for three pieces of information about a plot of land: tax amount, length, and width. If the width is 15 m or less, or the length is 25 m or less, the property owner receives a 20% tax discount. Calculate and display the corrected tax amount including this discount.  

5. Write a program that reads the lengths of three line segments (a, b, and c) from the keyboard and determines (and displays on screen) whether a triangle can be constructed from those segments. Three segments can form a triangle if and only if the sum of the lengths of any two sides is greater than the length of the third side.  

---

**Footnote:**  
34 The triangle inequality theorem.  

---


Here’s the full translation of the text from Hungarian to English:

---

**CHARACTERS AND CHARACTER STRINGS IN CONDITIONS**

**Comparing characters**

Characters (char) are stored as their ASCII codes, meaning they are stored as byte-sized numbers. The ASCII codes of characters were defined so that they increase in alphabetical order. For example, the code of the letter 'A' is 65, the code of 'B' is 66, and so on. The code of the letter 'b' is 98, and the code of 'c' is 99. Since 98 < 99, 'b' < 'c'. Characters can be directly compared using the relational operators we already know. Therefore, it’s not necessary to convert them to ASCII codes. For instance, if we want to know whether a variable named `capitalLetter` contains an uppercase letter from the alphabet, we can write the following condition:

```
if ('A' <= capitalLetter && capitalLetter <= 'Z') ...
```

It's not necessary to convert them even if we want to compare character codes directly, as automatic type conversion will handle this. Since the ASCII code of 'A' is 65 and that of 'Z' is 90, the previous condition is equivalent to:

```
if (65 <= capitalLetter && capitalLetter <= 90) ...
```

Unfortunately, this neat method does not work with accented letters, as ASCII codes were originally adapted to the English alphabet. Thus, in later extensions, accented letters were placed after the 127 ASCII codes, so after 'z' comes not 'á', but rather characters like 'á', 'b́', etc.

---

**Comparing character strings**

It often happens that we need to compare character strings: whether they are identical or which one comes first in alphabetical order. The latter is used, for example, when sorting into alphabetical order. The basis for comparison is also ASCII codes, so accented characters are not handled here either.

We can use relational operators here as well, just like with characters (<), to determine alphabetical order. To better understand this, let’s look at a simple example:

```
"aa" < "ba" - this is true because the first differing character is 'a' vs. 'b' and 'a' < 'b'.
"abc" < "abd" - this is true for the same reason.
"ab" < "abc" - this is true because after the common prefix 'ab', the shorter string is considered smaller.
"aa" < "aaa" - this is also true for the same reason; the shorter word comes first in alphabetical order.
```

---

Here is the full translation of the text from Hungarian to English:

---

**"aa" < "aaa", "ab" < "ba"** – Just for completeness.  

In **C++**, comparisons can be done with relational operators.  
In **C#**, comparisons are done using the **Compare** function, as shown in the figure. The return value of the comparison function is an integer, which is stored in variables sd1, sd2, and sd3. If the character string on the left side of the comparison is alphabetically earlier, the return value is -1; if the right side is earlier, it is 1; and if they are equal, it is 0. In line (4), we see how to use the result of the **Compare** function in conditional statements. In lines (4)–(6), the program always prints the one (between str1 and str2) that comes later in alphabetical order.

---

**C# version**  
```
1) int sd1 = String.Compare("isz", "obo");      → -1  
2) int sd2 = String.Compare("obo", "obo");      → 0  
3) int sd3 = String.Compare("obo", "isz");      → +1  
4) if (String.Compare(str1, str2) > 0)  
5)     Console.Write(str1);  
6) else Console.Write(str2);  
```

**C++ version**  
```
1) bool a = ("isz" < "obo")        → true  
2) bool b = ("isz" == "obo")       → false  
3) bool c = ("isz" > "obo")        → false  
4) if (str1 > str2)  
5)     cout << str1;  
6) else cout << str2;  
```

---

**Searching for a character string in a character string variable**

We can search for a character string in a variable using **Contains** (in C#) or **find** (in C++) functions, as shown in lines (11)–(14). In the example, the string **sz** contains the word **"farkas"** (wolf) (line 11). Then we look for the string **"farkas"** (line 12), and later for **"kutya"** (dog) (line 13).  

In **C#**, the function returns a logical value. It returns **true** if it found the substring (line 12), and **false** if not (line 13). This makes it easy to use in conditional statements (line 14).  

In **C++**, the function returns an integer. If the substring is found, it returns the position of the first occurrence of the character (in this example, the position of the letter 'f' in "farkas" would be returned) (line 12). If the substring occurs multiple times, it returns the position of the first occurrence. If the substring is not found in the variable (line 13), it returns a very large number (always the same value). For simplicity and readability, this large number is referred to as **string::npos** (npos – no position). Therefore, the conditional check for occurrence in line (14) can be formulated as shown.

---

**C# version**  
```
11) string sz = "van benne farkas";  
12) bool ered1 = sz.Contains("farkas")  → true  
13) bool ered2 = sz.Contains("kutya")   → false  
14) if (sz.Contains("kutya"))  
15)     Console.WriteLine("Van benne kutya");  
16) else Console.WriteLine("Nincs benne kutya");  
```

**C++ version**  
```
11) string sz = "van benne farkas";  
12) cout << sz.find("farkas");   → 10  
13) cout << sz.find("kutya");    → 4294967295  
14) if (sz.find("kutya") != string::npos)  
15)     cout << "Van benne kutya";  
16) else cout << "Nincs benne kutya";  
```

---

Here’s the full translation of the text from Hungarian to English:  

---

**Tasks**  

1. Decide for a given character whether it is a digit. The result should display "Digit" or "Not a digit."  
2. Decide for a given character whether it is a letter of the English alphabet. The result should display "Letter" or "Not a letter."  
3. Ask for a word. Print whether it begins with the letter 'e.'  
4. Ask for a word. Print whether it begins with a vowel of the English alphabet.  
5. Ask for two words. Print them in ascending order based on their length.  
6. Ask for five five-letter words. Write them in alphabetical order.  
7. Ask for five five-letter words, compare the three middle characters, and print the word that comes first alphabetically among those three-character substrings.  
8. Store the following text in a variable named "text": *"Komor komondorok utálják a vizsgázó vizslákat."* ("Gloomy komondors hate exam-taking vizslas.") Write a program that asks the user for a word and then prints whether that word can be found in the text.  

---

**BRANCHING BASED ON VALUE**  

**Operation and coding**  

At the beginning of branching, a variable (in the example, *vel*) is found, and the program compares it to the given values in each branch. If *vel* equals 1 (2), the branch belonging to 1 (3) will be executed. If *vel* equals 2 (4), the branch belonging to 2 (5) will be executed, and so on.  

The default branch runs if the value of the variable does not match any of the specified conditions. The use of the default branch is not mandatory.  

Multiple value matches can be given in one branch. We can see an example of this in line (10).  

There is no limit to the number of branches; the order of the branches is arbitrary.  

If a branch contains multiple instructions, they must be placed in a block.  

When coding, a break instruction is placed at the end of each branch. This means that after executing the branch, the program will continue after the branching structure. Without a break instruction, errors may occur as the program would evaluate the next conditions as well.  

The variable forming the basis of the branching must be of an integer or character type or something that can be mapped to such a type. Most commonly, the *int* and *char* types are used.  

> 35 Quoted from a performance by the Holló Theatre.  

---

If you’d like, I can help write the solutions for these exercises in any language you prefer!


Here’s the English translation of the text in the image:

---



#### Sentence-form description
Branching based on `val`  
   in case of 1:  
      page := 1  
   in case of 2:  
      page := 2  
   in case of 3:  
      page := 3  
   in case of 4:  
      page := 4  
   in case of 5, 6, or 7:  
     page := 5  
   Otherwise:  
     page := 6  
End of branching  

#### C language version

```cpp
    switch (val) {  
      case 1:  
         page = 1; break;  
      case 2:  
         page = 2; break;  
      case 3:  
         page = 3; break;  
      case 4:  
         page = 4; break;  
     case 5: case 6: case 7:  
        page = 5; break;  
     default:  
        page = 6; break;  
    }  
```

---

### Application  
Value-based branching can always be replaced by conditional branching. However, we tend to prefer it for multi-way branching when unnecessary complex conditions are not needed, as it is more transparent. For example, it is used in menus or in Windows to separate different events.  

---

### Tasks  

When solving the exercises, use value-based branching.  

1. Create a program that asks for a decimal number between 0 and 255 and converts it to a hexadecimal (base-16) number.  
2. Create a program that asks for a two-digit hexadecimal number (base-16) and converts it to a decimal number (base-10). (Do not use an associative array for the solution.)  

---

*36 Note: I wasn’t taught any “official” sentence-form description for value-based branching. So the description above is something I came up with.*

Here’s the full English translation of the text on the page:

---



3. Create a program that simulates a die. The display should be arranged so that the face of the die appears on the screen in a way that also displays the rolled side next to it in text form. The program should be able to "roll" randomly.  
a. All six sides should have an equal chance.  
b. The program should roll a six with twice the probability of any other number.  
c. The program should roll a six with three times the probability, and roll a one with twice the probability of any other number.  

---

### The principle of full coverage  

A program is generally not tested only once. We usually try out multiple possible values of a variable (or variables) by running the program separately for each. The program to be tested and one concrete value of the variable are called a *test case.* If we have multiple variables, each test case assigns a concrete value to each of them.  

The *principle of full coverage* states that the program should be tested (that is, the test cases should be chosen) so that every branch is tested.  

In the diagram below, two nested conditional branches can be covered with three test cases. Suppose these cases are: a = -5, a = 0, and a = 2.  

Full coverage is not a very strict form of checking. Test cases like the one shown in the image will reveal if someone wrote the condition `a > 1` in line (18). Later, if the user enters 1, the program would incorrectly treat it as invalid.  

Testing according to the principle of full coverage does not guarantee that the program is flawless. But it is an excellent filter. In complex branching systems, developers often forget to write code for rare cases or do not write correct code. Checking for this is where the principle of full coverage is perfect.  

---

### Tasks  

1. Carry out the testing of a conditional branching structure according to the principle of full coverage. Write down which program you tested with which values, and what the result was.  

2. Carry out the testing of a more complex conditional branching structure according to the principle of full coverage. Write down which program you tested with which values, and what the result was.  

---


Here is the full English translation of the text from the image:

---

### LOOPS

In computer science, it often happens that we need to repeat an operation or a sequence of operations. Just think of an assembly line in a car manufacturing plant, where a robot repeats the same sequence of movements countless times every day.

In programming, we solve the repetition of program sections using loops.

Loops are also commonly referred to as iterations.

There are several types of loops. The most basic ones are counter-controlled loops and conditional loops.

---

### COUNTER-CONTROLLED LOOP

We use a counter-controlled loop when, at the time of writing the program, we can decide how many times a program section needs to be repeated.

For example, if we want to display the text "Hello World!" fifty times on the screen, it is practical to use a counter-controlled loop.

---

### Description and Functionality in Sentence Form

At the beginning of the counter-controlled loop, we must assign a loop variable. The loop variable must always be of a countable type. Most often, we use integer types for this purpose.

Programmers usually follow the convention of using the letter `i` as the loop variable. Of course, we can use any other, more descriptive variable name as well. The loop variable is assigned a starting value, which indicates where the counting begins. 

The loop repeats until the value of the loop variable reaches the end value.

**Example structure:**

```
loop variable   start value   end value   increment

Loop i = from 1 to 50 with a step of 1
    Output: "Hello world!"   <-- loop body
End of loop

Output: "Instruction after loop."
```

Here is the full English translation of the second page:

---

The increment determines by how much each step of the counting increases. If not stated otherwise, the increment is 1.

The instructions found in the loop body are repeated every time the loop runs.

Both in sentence form descriptions and in code, the loop body is usually indented slightly. This helps make the program structure clearer and easier to read.

In the example, the loop counts from one to fifty, incrementing by one each time, so it repeats the instruction in the loop body fifty times. When the loop variable reaches the end value, the loop ends, and the program continues with the instruction after the loop.

The starting value can be larger than the end value; in this case, the loop will count down. In such cases, the increment is negative, and it must be explicitly specified.

---

### Coding

From the examples below, it is clear that we code counter-controlled loops the same way in C-like languages.

I slightly modified the previous example to make the use of the loop variable visible in the loop body. Now the program numbers each “Hello World!” line, something like this:

```
1. Hello World!
2. Hello World!
...
50. Hello World!
```

The end of the loop is not indicated separately. If there is a single instruction, it simply repeats.  
If there are multiple instructions in the loop body, we use a block of instructions, which is enclosed in braces to mark the end of the loop body.

---

### Coding in C#

| loop variable | start value | end value | increment | loop body |
|---------------|-------------|-----------|-----------|-----------|
```
int i;
for (i=1; i<=50; i++)
    Console.WriteLine("{0}. Hello World!", i);
```

---

### Coding in C++

| loop variable | start value | end value | increment | loop body |
|---------------|-------------|-----------|-----------|-----------|
```
int i;
for (i=1; i<=50; i++)
    cout << i << ". Hello World!" << endl;
```

---

The loop variable can also be declared with its starting value directly in the loop:

```
for (int i=1; i<=50; i++)
```

In this case, the loop variable can only be used inside the loop body and not after the loop.

---
Here’s the full English translation of the tasks from the image:

---

### Exercises

1. Print the text "Hello World!" ten times, each on a new line.  
2. Modify the previous task so that the line number appears before the text. Use the loop variable for this.  
3. Print the first ten positive even numbers on the screen!  
4. Print the sequence 100, 90, 80, ..., 10 on the screen!  
5. Print the following sequence on the screen with a loop:  
```
12345678901234567890123456789012345678901234567890
12345678901234567890123456789012345678901234567890
```
*(See footnote 37 for help.)*  

6. Print on the screen two independent loops with the following output:  
```
00000000001111111111222222222233333333334444444445
12345678901234567890123456789012345678901234567890
```

7. Print the number sequence from task 5 vertically:  
```
1
2
.
.
.
```

8. Print the number sequence from task 6 vertically:  
```
01
02
.
.
.
50
```

9. Print together on the screen the number sequences from tasks 5 and 7:  
```
12345678901234567890123456789012345678901234567890
1
2
.
.
.
```

10. Print together on the screen the number sequences from tasks 6 and 8:  
```
00000000001111111111222222222233333333334444444445
12345678901234567890123456789012345678901234567890
01
02
.
.
.
50
```

11. Store the days of the week in an array. Print the days of the week in order, separated by spaces.

---

**Footnote:**  
37. We divide the loop variable by 10 and print the remainder.

Here is the translation of the text from Hungarian to English:

---

12. Store the days of the week in an array. Print them on the screen in random order, separated by spaces.

13. For representing the tic-tac-toe game, we use three characters: 'X,' 'O,' and ' '. The latter represents empty spaces. Store the used characters in an array. Print the characters used for the tic-tac-toe game on the screen side by side.

14. Fill an array with 100 elements with random values or text, and print it on the screen like this: header text header text ... (Several solutions are possible. Try to find the most memory-efficient one.)

15. Fill an array with 50 elements with random dice values, and print them on the screen like this: 1 3 1 4 4 5 6 2 ...

16. Ask for a word and convert it into a character chain. Reverse this character chain and print it on the screen. (Example: rice → ecir. The reversal only happens on the screen, not in the original string.)

17. Create a character chain consisting of 20 characters randomly chosen from A, C, G, and T. Print the completed character chain on the screen.

18. In the file "6_szoveg," words can be found, each on a new line, stored in an array of 7825 elements. Write a program that reads this array through the clipboard and:
   a. Randomly selects a word.
   b. Prints a character string of the same length as the selected word, consisting entirely of X's, on the screen.
   c. Requests a character from the user. Wherever this character matches one in the word, print a new character string on the screen where the corresponding X is replaced by the guessed character.

---

Would you like me to help implement any of these exercises in code?

Here’s the full English translation of the text on the image:

---



**Tasks**  

1. Display a 50x50 grid of dots on the screen.  
```
..................................................
..................................................
..................................................
etc.
```

2. Display on the screen a grid with 50 rows, where each row contains an increasing number of dots by one.  
```
.
..
...
....
etc.
```

3. Display on the screen a grid with 50 rows, where each row contains a decreasing number of dots by one.  
```
..................................................
.................................................
................................................
etc.
```

4. Display a 50x50 grid on the screen, where the grid is filled in a chessboard pattern with the letters B and W (black, white).  
```
BWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBW
WBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBW
BWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWB
```

5. Expand the previous task by displaying row and column numbering as well.  
```
   00000000001111111111222222222233333333334444444444
   12345678901234567890123456789012345678901234567890
01 BWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBW
02 WBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBWBW
```

6. Store the state of a 3x3 tic-tac-toe board in a two-dimensional array. Possible values: X, O, or use `.` for empty fields. Display the board on the screen.  

7. Create a 20x20 board and fill it with random values. Possible values: X, O, or `.` for empty fields. Display the board on the screen.

---



---


**CONDITIONAL LOOPS**  

**Introduction**  

There are cases where the number of loop iterations cannot be planned in advance.  

For example, let's take a task where we need to determine the least common multiple (LCM) of two numbers (35 and 15). We use the following direct method: we list the multiples of each number (70, 105 and 30, 45, 60, 75, 105), and stop at the first common multiple (105). We generate these multiples by repeatedly adding the original number to the previous multiple (+35 and +15). We do not "run ahead" by guessing multiples, but always increment the smaller multiple, giving it a chance to "catch up" with the other.  

In such cases, the numbers given by the user and their properties determine how many times we need to repeat the increment operation, so it cannot be planned in advance.  

We will need loops where the repetition is dependent on a condition. In the example, we increase the smaller multiple until both multiples are equal. Loops that operate this way are collectively called **conditional loops**.  

A conditional loop has a start and an end, and the loop body sits between them. Depending on where we check the condition, we can talk about **pre-test loops** or **post-test loops**.  

---

### Pre-test loop  

Continuing the example, let's create the algorithm to determine the least common multiple.  

First, we ask the user for two numbers, whose least common multiple we want to determine (1). Then, we copy their values into auxiliary variables (C, D), where we will calculate the multiples (2). This is necessary because we will need the original numbers (A, B) as well (5) - (6).  

We always increase the smaller multiple (5) - (7): If D is smaller, then D = D + t (5), otherwise C = C + t (6).  

---

Let me know if you’d like me to help translate the next part or summarize the algorithm steps!

Here’s the full English translation of the text in the image you provided:

---

We need to repeat the increment, i.e., place a loop inside itself (4)–(8).  
The start of the loop is indicated by “Loop while” (4). The condition after “while” can be found within the loop.  
In this case, the loop must be repeated (i.e., remain in the loop) until the two multiples are equal.

Once the loop ends (8), we print one of the variables containing the common multiple (C), where the result will be found (9).

**1) Input: A, B**  
**2) C := A**  
**3) D := B**  
**4) Loop while C ≠ D**  
&nbsp;&nbsp;&nbsp;&nbsp;**5) If C > D then D := D + B**  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**else C := C + A**  
**7) End if**  
**8) End loop**  
**9) Output: C**  

*Condition: The condition for staying in the loop and the condition for branching apply the well-known rules: only expressions that can be evaluated as true/false are allowed. Compound conditions can also be used by combining simpler conditions with logical operators.*

If the user inputs two equal numbers, no increments are necessary.  
The loop is executed at least once. Generally, it is understandable that we use a pre-check loop when the loop body should not necessarily execute. A concrete example of this is found in file handling when reading a text file of unknown length until its end.

Lastly, it is worth mentioning to students being tested orally or in written exams that if the examiner asks them to write a pre-check loop in general, then only the “Loop while” and “End loop” lines from the example should be included, as the rest are only part of the specific example (See the Summary).

**Coding:**  
In C#, the beginning of the loop is marked with the `while` keyword. The condition is given in parentheses. The body of the loop consists of one or more statements, enclosed in curly braces if more than one.  

---

### C# version:

```csharp
int a, b, c, d;
Console.Write("Please enter the first number: ");
a = Convert.ToInt32(Console.ReadLine());
Console.Write("Please enter the second number: ");
b = Convert.ToInt32(Console.ReadLine());

c = a;
d = b;

while (c != d)
{
    if (c > d)
        d = d + b;
    else
        c = c + a;
}

Console.WriteLine("The least common multiple is: {0}", c);
Console.ReadLine();
```

---

### C++ version:

```cpp
#include <iostream>
using namespace std;

int main() {
    int a, b, c, d;
    cout << "Enter two numbers: ";
    cin >> a >> b;
    c = a;
    d = b;

    while (c != d) {
        if (c > d)
            d = d + b;
        else
            c = c + a;
    }

    cout << "The least common multiple: " << c << endl;
    return 0;
}
```

 
Here is the full English translation of the provided text:

---

### Backward-Testing Loop  

We are writing a program where we ask the user for a grade.  
It is possible that the user provides incorrect input. We want to avoid this by verifying the entered data.  
After receiving incorrect data, we will **repeat** the data request.  

We cannot determine in advance how many times the user will enter incorrect data in a row. The number of repetitions is unknown, so we will use a conditional loop. Since the data request must run at least once, it makes no sense to place the condition at the beginning of the cycle. Therefore, we use a backward-testing loop.  

The algorithm structure is as follows: First, we prepare the data request part (2) – (3). We place it inside the backward-testing loop (1) (4) (5). Finally, we specify the condition for remaining in the loop (4). The data request must be repeated until the entered number is less than one or greater than five.  

Generally, a backward-testing loop is a conditional loop where the condition is specified at the end of the loop. We use it when we cannot specify in advance how many repetitions will occur, only the condition or that it will run at least once.  

The condition can be given in the same way as for conditional branches, meaning it can be an expression that results in a true/false value. We can also create complex conditions by connecting simpler conditions with logical operations.  

Backward-testing loops are often used for verified data input or restarting a program. An example of this is a dice-throwing simulation program where pressing any key (except the spacebar) triggers a throw repeatedly. The program ends when the user presses the spacebar.  

**Coding:**  
The start of the loop is indicated with `do`, and the end with the `while` keyword. The loop body must always be enclosed in curly braces. If there’s only a single statement, the curly braces can be omitted. The condition is always given inside parentheses after the `while`.

---

**Cycle:**  
1) Loop  
2) Output: "Please give me a grade!"  
3) Input: a  
4) until (a < 1) or (a > 5)  
5) End of cycle  

---

### C# Version:
```csharp
int a;
do
{
   Console.Write("Please give me a grade! ");
   a = Convert.ToInt16(Console.ReadLine());
}
while ((a < 1) || (a > 5));
Console.ReadLine();
```

---

### C++ Version:
```cpp
int a;
do
{
   cout << "Please give me a grade! ";
   cin >> a;
}
while (a < 1 || a > 5);
cout << endl << a;
```


Here’s the full English translation of the provided text:  

---

## Infinite loops  

We can specify conditions in such a way that the program never exits the loop. It keeps repeating the loop body until we stop the program with external intervention. In technical terms, this is called the program entering an infinite loop.  

This is particularly annoying if it happens unintentionally due to an error. In such cases, nothing changes in the window, and no matter how much we try to use the keyboard or mouse on the affected window, it does not respond. The program appears to be frozen. In reality, it is doing something, but there is no visible sign of this to the user.  

While developing, if the program freezes, we can try to stop it with the Stop button in the development environment's menu bar, by closing the console window, or, if necessary, we can terminate it in the Task Manager.  

---

## Tasks  

1. Write a program that calculates the least common multiple of two numbers based on the theory covered! (If it doesn’t work on your own, you can look back in the book.)  

2. Extend the previous program so that it first checks the numbers entered by the user and only allows the program to continue if both numbers are greater than zero. (If you can’t solve it on your own, refer to the verified data input using a backward-testing loop covered earlier in the book.)  

3. Determine the greatest common divisor (GCD) of two positive integers using the following algorithm:  
   - If the two numbers are equal, that is the GCD.  
   - If they are not equal, subtract the smaller one from the larger one and repeat with the new values. (See the illustration in the appendix.)  

4. Extend the program in point 3 so that it only accepts inputs that are multiples of 10 and positive. The user should be able to exit by entering 0 or a negative number. No other checks are necessary.  

5. Write a program that determines whether a given positive integer is a prime number. (Use the sieve of Eratosthenes if needed.)  

6. Write a program that lists the prime factorization of a given positive integer.  


Here’s the full English translation of the text in the image:

---

### TRACKING (DEBUGGING)

**The purpose and tools of tracking**

**Tracking** refers to examining the values of variables and expressions formed from them during the execution of a program. This might be necessary if our program runs but does not perform what we expect. This indicates a semantic error, and by just reading the code, we cannot detect the problem.  

Modern development environments automatically display the contents of variables in smaller windows (such as **Watches**, **Locals**). We can add expressions composed of variables to the watch list, for example, conditions of branches or loops, making it easier to identify the source of the error.  

The program can be **executed step by step**, and after each instruction, we can check the values of variables and expressions. The development environment shows where the execution currently is, usually marked by a yellow arrow at the beginning of the line.  

However, in a large program, pinpointing the error this way would take a lot of time. Once we have approximately located the error, we can place a **breakpoint** at the beginning of the suspected area. In the development environments discussed in the book, this is indicated by a red dot at the start of the line. The program can then be run until it reaches the breakpoint, so we don't have to execute each instruction manually in the erroneous part. At the breakpoint, the program execution stops, and we can check the values of variables and expressions. Multiple breakpoints can be set in the program, and we can jump from breakpoint to breakpoint during execution. Of course, execution can also be continued from the breakpoint step by step if desired.  

---

### **C# - Step-by-step execution, monitoring variables**  

1. Open the project in which we defined the smallest common multiple (likely a loop or test cycle).  
2. Start step-by-step execution by pressing the F11 key.  

---

Here is the full English translation of the text on the page:

---

**3.** A yellow arrow and a highlighted instruction in yellow show where the program is in execution (20). Meanwhile, in the running program window, we can see the effect of the command just executed. Do not click on the running program window (do not make it active), because the next key command will not work (as it would not apply to the code window but to the program window). During data entry, the tracking mode automatically switches to the console window and then back to the code window.

**4.** Click on the **Locals** menu item at the bottom. Just above it, the names of the program's variables and their values will appear.

**5.** Press **F11** again and again until the program runs completely. Each time, observe the values of the variables.

---

### **C# - Using breakpoints, monitoring expressions, exiting**

**1.** Set a breakpoint on the line with the `while` keyword: click on the line, then press the **F9** key. A red dot will appear at the beginning of the line, and the line will be highlighted in red (20).

**2.** Run the program step by step (not line by line) to the breakpoint by pressing the **F5** key. The program execution will stop just before the `while` loop.

**3.** Click on the **Watch1** menu item at the bottom (2). Above it, you can add your own expressions to monitor.

**4.** Click on the empty field under **Name** and type the expression to be monitored. For example, now: `c > d`. After leaving the field, the current value will immediately appear next to it.

---

Here’s the full English translation of the text on the provided page:

---

**5. Continue running the program until the next breakpoint, i.e., until the start of the next cycle: to do this, press the F5 key again.**  
**6. Press the F5 key a few times, and after each press, observe the entered expression as well as the changes in the values of the variables. To do this, switch between the Local and Watch1 windows at the bottom.**  
**7. To stop tracing, press the Shift + F5 key combination.**  
**8. To remove the breakpoint, click on the line of the while loop and then press the F9 key.**  

---

### C++ - Creating a project  

1. Select the File/New/Project menu option.  
2. In the window that appears, double-click on the Console application icon.  
3. Click on the Next button.  
4. In the next window, select the C++ option, then click the Next button.  
5. In the next window, enter the project name in the Project title field. For example: nyomkovetes (tracing).  
6. Provide the project folder in the Folder to create project in field. (You can also open the folder selection dialog by clicking the "..." button.)  
7. Click the Next button.  
8. In the window that appears, we don't need to set anything, just click the Finish button.  
9. From the project tree on the left, select Workspace/nyomkovetes/Sources/main.cpp. As a result, a basic program will appear on the right side of the screen.  

---

### C++ - Step-by-step execution, monitoring variables  

Tracing can only be done within a project, so if you don't have a project yet, follow the instructions above!  

1. Copy the smallest common multiple determination program (using conditional loops/Pre-test loops) into the code of the previously created project. Try running it step by step. If it works as expected, proceed further.  

Here’s the full English translation of the text on the provided page:

---

**5. Continue running the program until the next breakpoint, i.e., until the start of the next cycle: to do this, press the F5 key again.**  
**6. Press the F5 key a few times, and after each press, observe the entered expression as well as the changes in the values of the variables. To do this, switch between the Local and Watch1 windows at the bottom.**  
**7. To stop tracing, press the Shift + F5 key combination.**  
**8. To remove the breakpoint, click on the line of the while loop and then press the F9 key.**  

---

### C++ - Creating a project  

1. Select the File/New/Project menu option.  
2. In the window that appears, double-click on the Console application icon.  
3. Click on the Next button.  
4. In the next window, select the C++ option, then click the Next button.  
5. In the next window, enter the project name in the Project title field. For example: nyomkovetes (tracing).  
6. Provide the project folder in the Folder to create project in field<sup>41</sup>. (You can also open the folder selection dialog by clicking the "..." button.)  
7. Click the Next button.  
8. In the window that appears, we don't need to set anything, just click the Finish button.  
9. From the project tree on the left, select Workspace/nyomkovetes/Sources/main.cpp. As a result, a basic program will appear on the right side of the screen.  

---

### C++ - Step-by-step execution, monitoring variables  

Tracing can only be done within a project, so if you don't have a project yet, follow the instructions above!  

1. Copy the smallest common multiple determination program (using conditional loops/Pre-test loops) into the code of the previously created project. Try running it step by step. If it works as expected, proceed further.  

---

<sup>41</sup> Specify a folder that exists on your computer; it will automatically display the path as shown in the image.  

---
Here is the full English translation of the text in the image:

---



5. To continue running the program to the next breakpoint, i.e., the beginning of the next cycle, press the F4 key again.  
6. Press the F4 key several times and after each press, observe the expression entered and the change in the value of the variable.  
7. To stop tracing, press the Shift + F8 key combination.  
8. To remove the breakpoint, click in the line with the `if` statement, then press the F5 key.

---

**Tasks**

1. Select one of the previously created short (simple) programs, and follow its execution using the known tools.  
2. Select one of the previously created longer (more complex) programs, and follow its execution using the known tools.

---

**JUMP STATEMENTS, STRUCTURED PROGRAMMING**

**Jump statements**

There are commands that allow the program to jump to a completely different point in the code. We will now refer to these collectively as *jump statements*.  

A typical example is the `goto` statement, which allows you to jump to a location marked with a label. The label name can be chosen freely, as seen in the diagrams below with the labels `vissza` (back) and `ki` (exit). In the example program below, you can see how easily a `goto` statement with a label (`vissza`) can create an infinite loop in the program (see the arrow pointing from the end of the program to the beginning).  

In the C language, the `break` statement is also present, allowing the program to exit the current loop and continue executing the code following the loop. If we want to exit multiple nested loops at once, we can also achieve this using a `goto` statement, as `break` only exits one loop level at a time.

---

Here is the full English translation of the text in the image:

---

### **C# version**  

```csharp
vissza:  
int a;  
do  
{  
    Console.WriteLine("Please enter a divisor!");  
    a = Convert.ToInt16(Console.ReadLine());  
    if (a == 0) break;  
} while ((a % 4) != 0);  
int[] ki = new int[11];  
int i, j = 0;  
for (i = 0; i < 11; i++)  
{  
    for (j = 0; j < 11; j++)  
    {  
        if ((i * j) == a) goto ki;  
    }  
}  
Console.WriteLine("{0} = {1} * {2}", a, i, j);  
goto vissza;  
ki:  
```

---

### **C++ version**

```cpp
vissza:  
int a = 0;  
do  
{  
    cout << "Please enter a divisor!" << endl;  
    cin >> a;  
    if (a == 0) break;  
} while ((a % 4) != 0);  
int ki;  
for (int i = 0; i <= 10; i++)  
{  
    for (int j = 0; j <= 10; j++)  
    {  
        if ((i * j) == a) goto ki;  
        cout << i << " * " << j << endl;  
    }  
}  
ki:  
cout << i << " * " << j << endl;  
goto vissza;  
```

---

### **Structured programming**

Exiting loops "in the middle" and jumping around even in a program of just a few lines makes the program completely unreadable and therefore impossible to develop further.  

Structured programming is a fundamental principle of program design. It states that our program’s fine structure should consist only of sequences, branches, and loops. More complex structures will later be formed by procedures and functions. In other words, we should not use jump statements.  

Can every task be solved without jump statements, or are there situations where jump statements are necessary? This question was successfully answered by Böhm and Jacopini with a theorem stating that every algorithm can be constructed from sequences, branches, and loops — all having a clear beginning and end.  

Therefore, jump statements are not needed in our programs. Those who still use them do so out of laziness or convenience because they don’t have to think as much. However, this convenience comes at the price of an unmaintainable program — a price too high for such a benefit.  

Why, then, are jump instructions still present in programming languages? In machine code and assembly, they are unavoidable. When high-level languages were first developed, they naturally built on elements of low-level languages. Some older high-level languages did not yet have structured programming tools. For example, in the Commodore 64 Basic language, conditional jumps and loops were missing. In such cases, jumps were the only solution.  

Later, these elements were incorporated into languages, but jump statements remained to ensure backward compatibility so that previously written programs could still run. Structured programming has become a mandatory expectation in modern education, but older programs can still be easier to understand this way. On one hand, understanding it helps interpret old code; on the other hand, mastering structured thinking early is better than adopting bad habits and relying on incorrect solution patterns.  

---

Here’s a full English translation of the text in the image:

---



### SUMMARY

### General usage of control structures

- **Sequence:** sequential execution of instructions.
- **Branches (selections):** creation of decision-making. Conditional execution.
- **Loops (iterations):** repetition of a program part.
- **Unconditional jumps:** the program jumps to another part.

---

### Coding branches

| Conditional |   |
|-------------|---|
| If `<condition>`<br> then<br> `<instructions1>`<br> else<br> `<instructions2>`<br> End of branch | `if (<condition>) {`<br>`<instructions1>`<br>`} else {`<br>`<instructions2>`<br>`}` |

| By value |   |
|----------|---|
| Branch based on `<variable>`:<br>`<value1>`: `<instructions1>`<br>`<value2>`: `<instructions2>`<br>`<value3>`, `<value4>`: `<instructions3>`<br>otherwise: `<instructions4>`<br>End of branch | `switch (<variable>) {`<br>`case <value1>:`<br>`<instructions1>`; `break;`<br>`case <value2>:`<br>`<instructions2>`; `break;`<br>`case <value3>:` `case <value4>:`<br>`<instructions3>`; `break;`<br>`default:`<br>`<instructions4>`; `break;`<br>`}` |

---

### Coding loops

#### Counter loop

Loop `<loopVariable>` := from `<startValue>` to `<endValue>` by `<increment>`<br>
Loop body<br>
End of loop

```c
for (<loopVar> = <startValue>; <loopVar> <= <endValue>; <loopVar> += <increment>) {
   Loop body
}
```


Here is the full translation of the page:  

---

**Conditional loops**  

|                       | Pre-test loop                                    |  
|-----------------------|--------------------------------------------------|  
| Algorithm             | while (<condition>) {                            |  
|                       |   loop body                                      |  
|                       | }                                                |  
|                       | Post-test loop                                   |  
|                       | do {                                             |  
|                       |   loop body                                      |  
|                       | } while (<condition>);                           |  

---

### Creating complex conditions with logical operations  

| A     | B     | A ∧ B | A ∨ B | ¬A    |  
|-------|-------|-------|-------|-------|  
| true  | true  | true  | true  | false |  
| true  | false | false | true  | false |  
| false | true  | false | true  | true  |  
| false | false | false | false | true  |  

| Operation   | Algorithm notation         | C languages                   |  
|-------------|----------------------------|--------------------------------|  
| AND (ÉS)    | x >= 1 ∧ x <= 8            | x >= 1 && x <= 8              |  
| OR (VAGY)   | x >= 1 ∨ x <= 8            | x >= 1 \|\| x <= 8            |  
| NOT (NEM)   | ¬(x >= 1)                  | !(x >= 1)                     |  

**Operator precedence:** parenthesized expression > NOT > AND > OR  

---

### Using loops  

**Flowchart:**  

**Start**  
→ Do we know in advance how many times it will run?  
- If yes → Counting loop (for...)  
- If no → Does it have to run at least once?  
   - If yes → Post-test loop (do... while)  
   - If no → Pre-test loop (while...)  

**Stop**  

---

*To traverse an array, you need to nest as many loops as the number of dimensions of the array.*

Here is the full translation of the page:  

---



**Tracing (Debugging)**  

| Task                                       | C#                  | C++                |  
|--------------------------------------------|---------------------|--------------------|  
| Start execution step by step               | F11                 | Shift + F7         |  
| Jump to the next line                      | F11                 | F7                 |  
| Set/remove breakpoint                      | F9                  | F5                 |  
| Execute until the next breakpoint          | F5                  | F4                 |  
| Stop debugging                             | Shift + F5          | Shift + F8         |  
| Value of variables                         | Locals window       | Watches window     |  
| Value of defined expressions               | Watch1 window       | Watches window     |

