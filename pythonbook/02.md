
II. BASICS OF PROGRAMMING
1. General structure of a program

### **II. Fundamentals of Programming**  
#### **1. General Structure of a Program**

A computer program consists of three main components:  
1. **Data Structure**  
2. **Business Logic**  
3. **User Interface**  

For simple scripts, these elements may blend together, but in large-scale software, they are clearly separated.

---

### **1Ô∏è‚É£ Data Structure**
- Programs **store and manage data**, whether permanent or temporary.
- Various **data structures** include:
  - **Variables** ‚Äì Store simple values.
  - **Files** ‚Äì Store structured data.
  - **Databases** ‚Äì Manage large datasets.
- The **choice of data structure** affects efficiency and functionality.
- Well-structured data organization **improves performance and maintainability**.

---

### **2Ô∏è‚É£ Business Logic (Application Logic)**
- The **core functionality** of the program.
- Defines **what the program does**.
- Can range from **simple operations** to **complex rule-based systems**.
- Often **separated from the user interface** to keep functionality independent.

---

### **3Ô∏è‚É£ User Interface (UI)**
- **Where users interact** with the program.
- Displays **messages, results, and input fields**.
- UI can be:
  - **Command-line based (CLI)**
  - **Graphical (GUI)**
  - **Web-based**
- Good UI design emphasizes **clarity and usability**.

---

### **Key Takeaways**
‚úÖ **Data Structures** ‚Äì Efficient storage and management.  
‚úÖ **Business Logic** ‚Äì Defines how the program operates.  
‚úÖ **User Interface** ‚Äì Enables interaction with the program.  

A well-structured program **separates these three components**, making it **easier to develop, maintain, and scale**! üöÄ

-----

### **Console Applications & Algorithms**

#### **Console Applications (Konzolalkalmaz√°sok)**
- Programs that only display **text-based output**.
- Used in **basic programming education** and **automation scripts**.
- **High school programming exams** require console applications only.
- Useful for **testing basic programming techniques** before adding a GUI.
- **Web applications** focus heavily on UI, requiring more development effort.

---

## **2. ALGORITHMS**
### **Definition of an Algorithm**
- An **algorithm** is a **step-by-step sequence** of instructions for solving a problem.
- Examples include:
  - **Cooking recipes**
  - **Assembly instructions**
  - **Mathematical procedures (e.g., prime factorization)**

> **Algorithms describe logical steps**, much like saying: *"Break three eggs!"*

---

### **Algorithm Representation Methods**
- Algorithms are often written **independently of programming languages**.
- This has two advantages:
  1. **More readable and structured** ‚Äì Easier to understand and modify.
  2. **Can be implemented in different languages**.

Algorithms **serve as blueprints**, and their logic can be later translated into **specific programming languages**.

This section introduces **fundamental problem-solving techniques**, making programming **clearer and more structured**! üöÄ

-----

### **Algorithm Representation Methods**
Algorithms can be described in **various ways**, depending on the level of **formality and precision** required.

---

### **1Ô∏è‚É£ Sentence-Based Description (Mondatos Le√≠r√°s)**
- The **simplest** form of algorithm representation.
- Uses **plain sentences** like a **recipe**.
- Example: *"Get two numbers, add them, display the result."*
- **Limitations**:
  - Not always precise enough.
  - Difficult to convert into code.
  - Not structured for computer execution.

---

### **2Ô∏è‚É£ Flowcharts (Folyamat√°bra)**
- A **graphical** way to **visualize an algorithm**.
- Uses **different shapes** for:
  - **Parallelogram** ‚Äì Input/output (`Be:` for input, `Ki:` for output).
  - **Rectangle** ‚Äì Process (e.g., calculations).
  - **Diamond** ‚Äì Decision-making (not shown in this example).
- **Advantages**:
  - Easy to **read and understand**.
  - Shows the **flow of execution** clearly.
- **Disadvantages**:
  - Takes **more space**.
  - Not ideal for **very large algorithms**.

---

### **3Ô∏è‚É£ Pseudocode (Pszeudok√≥d)**
- A **structured textual representation** of an algorithm.
- **Looks like programming code** but is **not tied to a specific language**.
- **Example**:
  ```pseudo
  START
  INPUT A
  INPUT B
  C = A + B
  OUTPUT C
  STOP
  ```
- **Benefits**:
  - More **formal** than sentence-based descriptions.
  - **Easier to convert into real code**.
  - **Better for larger algorithms**.

---

### **Algorithm Representation with Flowcharts**
The example shows a **simple addition program**:
1. **Start**
2. **Get input (A and B)**
3. **Calculate C = A + B**
4. **Display the result**
5. **Stop**

This teaches **basic flowchart elements** that later help in **programming logic and control structures**.

---

### **Key Learning Points**
‚úÖ **Sentence-based** ‚Äì Easy but **not precise**.  
‚úÖ **Flowcharts** ‚Äì Visual and structured.  
‚úÖ **Pseudocode** ‚Äì Best for **formal, structured algorithm design**.  

These methods **help plan algorithms** before coding, making programming **more structured and efficient**! üöÄ

----

### **Algorithm Representation & Algorithmization**

---

### **Algorithm Representation Using Sentence-Based Description**
A simple way to describe an algorithm is by writing its **steps in short sentences**, one below the other.

#### **Example: Addition Program in Sentence-Based Form**
```
Be: a
Be: b
c := a + b
Ki: c
```
- **"Be:"** indicates **input** (values `a` and `b`).
- **":="** represents **assignment** (`c = a + b`).
- **"Ki:"** represents **output** (`c` is displayed).

This format **simplifies understanding** while maintaining clarity.

---

### **Algorithmization (Algorithm Design)**
- The **process of constructing an algorithm** is called **algorithmization**.
- Some problems have an **obvious solution**, while others require **deep thinking and different methods**.
- **Key Challenges**:
  - Choosing the right **sequence of steps**.
  - **Testing multiple approaches**.
  - **Some problems may not have a solution**.

#### **Solving Problems with Existing Knowledge**
- **Easier algorithmization** happens when a **previously learned formula, standard algorithm, or method** applies.
- Common approaches:
  - **Mathematical formulas**
  - **Predefined algorithm patterns**
  - **Known problem-solving techniques**

---

### **Key Takeaways**
‚úÖ **Sentence-based description** is **simple** but lacks **structured control**.  
‚úÖ **Algorithmization** involves **choosing the best steps** to solve a problem.  
‚úÖ **Recognizing familiar patterns** makes algorithm creation easier.  

Understanding **different algorithm representations** makes programming **clearer, structured, and efficient**! üöÄ

----

### **3. Programming Languages**
#### **Machine Code (G√©pi k√≥d)**
- **Early computers were programmed directly in machine code**.
- Programmers entered **binary data byte-by-byte** into memory.
- The image shows **a machine code program** stored in the memory of a **Commodore Plus/4** computer.
- The program begins at **memory address `2000` (hexadecimal)**.
- Each **two-digit hexadecimal number** represents **one byte** (e.g., `A9` or `8D`).

---

### **Understanding Machine Code Execution**
- Machine code follows the **Von Neumann architecture**:
  - **Instructions and data are stored in the same memory**.
  - Example: `A9` is an **instruction**, followed by `02`, which is **data** (color code).
  - Another instruction, `8D`, stores the value in a **register**.
  - Memory address `FF19h` holds the **screen border color**.

- **Challenges of Machine Code**:
  - Writing machine code **is slow and complex**.
  - Programmers must **think like a processor**.
  - Machine code programs are called **binaries**.

---

### **Assembly Language**
- **Assembly was created to simplify machine code**.
- Uses **mnemonics (short words) instead of hexadecimal numbers**.
- Example:
  - Machine code: `A9 02`
  - Assembly: `LDA #$02` (*Load value `02` into the accumulator*).

---

### **Key Takeaways**
‚úÖ **Machine code** is **fast but difficult to write**.  
‚úÖ **Assembly language** simplifies coding but is **still hardware-specific**.  
‚úÖ **Both are "low-level languages"**, close to hardware.  

This section introduces **how computers execute code**, leading to **higher-level programming languages**! üöÄ

-----

### **High-Level Programming Languages**
#### **From Assembly to High-Level Languages**
- **Assembly language** made programming easier than **machine code**, but it was still **hardware-specific**.
- **Higher-level programming languages** were created to **match human thinking** more closely.
- Examples of **early high-level languages**:
  - **C**
  - **Pascal**
  - **Basic**
- These languages **simplify programming**, requiring **less technical hardware knowledge**.

---

### **Compiled vs. Interpreted Languages**
1. **Compiled Languages** (e.g., C, C++)  
   - The **source code** is written in a high-level language.
   - A **compiler** converts it into **machine code (binary)**.
   - **Advantages**:
     - **Fast execution** (runs directly on hardware).
     - Optimized for performance.
   - **Disadvantages**:
     - Requires **compilation** before running.
     - **Less flexible** for quick changes.

2. **Interpreted Languages** (e.g., Python, JavaScript)  
   - The **source code** is read and executed line-by-line by an **interpreter**.
   - **Advantages**:
     - Easier to test and modify.
     - No need to compile before running.
   - **Disadvantages**:
     - **Slower execution** than compiled languages.
     - Requires an **interpreter** to run.

---

### **Python as an Interpreted Language**
- **Python runs directly from source code**.
- It **does not generate `.exe` files** by default.
- Python has both a **compiler** and an **interpreter** but mainly relies on **interpretation**.

---

### **Key Takeaways**
‚úÖ **High-level languages are easier to use than assembly and machine code**.  
‚úÖ **Compiled languages (e.g., C) offer speed, but require compilation**.  
‚úÖ **Interpreted languages (e.g., Python) provide flexibility but are slower**.  

This section introduces **the evolution of programming languages**, showing how **modern languages simplify development**! üöÄ

----

4. Errors
5. Steps in program development

